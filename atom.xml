<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiangjinxinn.github.io/</id>
    <title>空调房</title>
    <updated>2020-04-06T07:42:44.133Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiangjinxinn.github.io/"/>
    <link rel="self" href="https://jiangjinxinn.github.io/atom.xml"/>
    <logo>https://jiangjinxinn.github.io/images/avatar.png</logo>
    <icon>https://jiangjinxinn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 空调房</rights>
    <entry>
        <title type="html"><![CDATA[Netty 增强写 FlushConsolidationHandler]]></title>
        <id>https://jiangjinxinn.github.io/post/netty-zeng-qiang-xie/</id>
        <link href="https://jiangjinxinn.github.io/post/netty-zeng-qiang-xie/">
        </link>
        <updated>2020-02-06T06:33:13.000Z</updated>
        <content type="html"><![CDATA[<p>如果追求吞吐量，可以不用 ctx.writeAndFlush()，这种写数据是在每次 write 后都立即 flush，加急写数据。</p>
<p>在 FlushConsolidationHandler 类的注释上有说明这个问题：</p>
<blockquote>
<p>Flush operations are generally speaking expensive as these may trigger a syscall on the transport level. Thus it is in most cases (where write latency can be traded with throughput) a good idea to try to minimize flush operations as much as possible.</p>
</blockquote>
<p>相反，我们可以通过添加一个增强写的 Netty 的 FlushConsolidationHandler来处理这个事情，这个 Handler 有一个参数 explicitFlushAfterFlushes 可以控制拦截几次 flush 后才进行真正的 flush操作。</p>
<p>这里提到 FlushConsolidationHandler 可以拦截，那么不用想，肯定是继承了 ChannelDuplexHandler。</p>
<p>这里不知道大家有没有一个问题，在添加 FlushConsolidationHandler 设定了 explicitFlushAfterFlushes 之后看，如果 flush 次数不够难道就一直不 flush 出去了，需要等到后边一次请求进来的出站事件到来后 flush 够了才能写吗？</p>
<p>这个问题肯定不是的，如果是的话就是个严重的缺陷的。</p>
<p>这个问题我们通过查看 FlushConsolidationHandler 源码来说明下</p>
<p>关键点在 flush 方法上，需要说明的是在任意一个 ctx 上执行 flush 的时候，会根据 pipeline 上设置的 ChannelHandlerContext，寻找下一个 outBoundHandler 传递下去，到 FlushConsolidationHandler 时候就会被拦截下来</p>
<pre><code>@Override
public void flush(ChannelHandlerContext ctx) throws Exception {
    if (readInProgress) {
        // If there is still a read in progress we are sure we will see a channelReadComplete(...) call. Thus
        // we only need to flush if we reach the explicitFlushAfterFlushes limit.
        if (++flushPendingCount == explicitFlushAfterFlushes) {
            flushNow(ctx);
        }
    } else if (consolidateWhenNoReadInProgress) {
        // Flush immediately if we reach the threshold, otherwise schedule
        if (++flushPendingCount == explicitFlushAfterFlushes) {
            flushNow(ctx);
        } else {
            scheduleFlush(ctx);
        }
    } else {
        // Always flush directly
        flushNow(ctx);
    }
}
</code></pre>
<p>Netty 源码上的注解已经很好的说明了，有一个变量 readInProgress 标识是否正在读（即读事件未结束），这里我们先不查看 consolidateWhenNoReadInProgress 这个分支。如果 readInProgress 标记正在读 FlushConsolidationHandler 就会进行继续进行拦截，直到 flush 次数满足了后才会进行最后的 flush，读事件已经结束的话直接调用最后的 flush</p>
<p>这就解答了上面的问题，如果 flush 次数不够，但是读事件已经结束了，依然会进行 flush。</p>
<p>这时不知道大家有没有一个问题，那就是感觉这个 FlushConsolidationHandler 没什么用，因为作为开发者，我只要不调用 ctx.writeAndFlush() 即可，只调用 ctx.write ()，然后再后续 flush 掉。</p>
<p>对的，这个在 Netty 的官方 demo 中就是这样实例的，只在读事件结束后才进行 ctx.flush()</p>
<pre><code>/**
 * Handler implementation for the echo server.
 */
@Sharable
public class EchoServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre>
<p>那么这个 FlushConsolidationHandler 是怎么使用的呢？</p>
<p>这个 FlushConsolidationHandler 主要是在异步写（在 handler 上添加了线程池）的时候使用的，拦截多次异步写即通过前面 consolidateWhenNoReadInProgress 来控制，而且为了防止异步写未执行够设定的 explicitFlushAfterFlushes ，会添加一个 future 来进行调用最后的 flush</p>
<p>因为 Netty 的线程模型是一个 pipeline 绑定一个同一个 eventLoop，所以不会有并发执行的问题，同时不会有多个读事件在一个 pipeline 上发生，在同一次读事件未结束之前（未调用channelReadComplete 之前） 都会是 readInProgress true，保证 flush 的执行可以在读事件处理完后进行，如果读事件结束了，就可以直接 flush 出去。</p>
<p>但是在一个 pipeline 上的读事件完成了不带表真正的读事件完成了，如果读事件是在另起一个线程池的业务线程中执行的，虽然当前 pipelin 上的读事件已经返回了，但是可能还没有调用 writeAndFlush。<br>
consolidateWhenNoReadInProgress 参数的存在就是为了应对这种问题。</p>
<p>看下实例的异步写情况：</p>
<pre><code>UnorderedThreadPoolEventExecutor eventExecutors = new UnorderedThreadPoolEventExecutor(10);
try {
    serverBootstrap.group(boss, worker)
            .handler(new LoggingHandler(LogLevel.INFO))
            .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {
                protected void initChannel(NioSocketChannel ch) throws Exception {
                    ChannelPipeline pipeline = ch.pipeline();

                    pipeline.addLast(new ServerIdleCheckHandler());
                    pipeline.addLast(&quot;frameDecoder&quot;, new FrameDecoder());
                    pipeline.addLast(&quot;frameEncoder&quot;, new FrameEncoder());

                    pipeline.addLast(&quot;protocolEncoder&quot;, new ProtocolEncoder());
                    pipeline.addLast(&quot;protocolDecoder&quot;, new ProtocolDecoder());


                    pipeline.addLast(new LoggingHandler(LogLevel.INFO));
                    pipeline.addLast(eventExecutors, &quot;serviceHandler&quot;, serviceDispatchHandler);

                }
            });
    ChannelFuture sync = serverBootstrap.bind(8098).sync();
</code></pre>
<p>pipeline.addLast(eventExecutors, &quot;serviceHandler&quot;, serviceDispatchHandler); 关键在这行代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# 2019]]></title>
        <id>https://jiangjinxinn.github.io/post/2019/</id>
        <link href="https://jiangjinxinn.github.io/post/2019/">
        </link>
        <updated>2020-01-25T07:33:16.000Z</updated>
        <content type="html"><![CDATA[<p>网上看了些年终总结，大多数还是打广告性质的，讲述下自己这一年干了啥，作为论述下自己很牛逼的证据，确实，一眼看下来感觉他们输出真的牛逼，暗暗和自己对比了下，心里泛起了嘀咕，咋人与人之间差距这么大呢?</p>
<p>我在以前看到自己写的笔记和日记时都会想要删掉它们，心里还要疑问下，这个傻逼是我？慢慢的体会到时间飞逝，留下来一些记录也挺有意思的，傻逼的自己也是自己，所以有了这篇总结。</p>
<hr>
<p>想来从 2018 年 6 月毕业至今马上就要工作两年了，和每次回想以前的事一样，都会感叹时间过的之快。</p>
<p>感觉现在技术水平算是入了个门吧，从刚开始来公司的时候，idea 用不来，上网查教程到现在上网查看面试题，学习的过程就是这个样子吧。</p>
<p>想起第一次看到组长代码里用 BeanUtils 的 copyProperties 方法，第一次看到同事用 ApplicationContextAware 时候的惊讶，看到同事封装 react 写个类的时候，看到公司内部使用的框架是主管写的时候，我小小的内心都被震撼了。有一次听到隔壁组的同事说分布式锁的时候，更是浑身抖擞了一下，太牛逼了，心里不断的发出感叹。</p>
<p>然后就是稳步进行中的搬砖事业，被 react 前端吊打的过程，从 java 基础开始恶补知识。</p>
<p>印象更深的就是今年年中的时候组里来了个实习生，想下同期的自己在干啥，更加感觉自己太菜了，还要加把劲，但总又感觉有点奇怪，算来也 25 岁了，咋还要每天学习。。</p>
<p>年中以后换了个组，开始写点超出我水平的代码，写都写不来，只能去抄代码。。看 nacos 代码的时候，被代码里的心跳连接惊艳了，顿时感觉自己之前不知道在干啥，憨憨的一样。好在虽然项目超时了，组长也只能背后嘀咕下超时了超时了，也不会说啥。。。</p>
<p>慢慢心里觉得公司 low 的感觉越来越强烈，code review 都没有啊，还要老是强调代码规范，同事 maven 打个 jar 包都老是翻车坑我，什么情况啊。公司的文化也越来越熟悉，熟悉后随之而来的是有点失望。</p>
<p>这一年绩效也不好看，心态时常爆炸。好在现在能稳的住了。</p>
<p>我希望这里就算做是对事实的描述，而不是抱怨，毕竟抱怨不能解决问题，也没人会喜欢负能量。但这里还是会如实的记录下我后面对公司的看法，不做修饰。</p>
<hr>
<p>总的来说，我觉得我还是幸运的，在公司的时候主要还是在学习，有时干些超出自己水平的事。更难能可贵的是心态得到了锻炼，这种财富还是更加珍贵的。</p>
<p>想起主管对我说，有些东西只有你在一家公司待的足够久才会明白。我觉得我明白了一些了，但我不能确定是不是他所说明白的东西。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Netty 对 Reactor 模式常见的疑问]]></title>
        <id>https://jiangjinxinn.github.io/post/netty-dui-reactor-mo-shi-chang-jian-de-yi-wen/</id>
        <link href="https://jiangjinxinn.github.io/post/netty-dui-reactor-mo-shi-chang-jian-de-yi-wen/">
        </link>
        <updated>2019-12-15T12:34:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="netty-如何支持主从-reactor-模式">Netty 如何支持主从 Reactor 模式</h2>
<p>简单来说就是将 两种 channel 注册到两种 EventLoopGroup上。<br>
主要的逻辑在 引导类 <code>ServerBootstrap</code> 的 group() 中配置了 BossGroup 和 WorkGroup，会在后面 register() 完成初始化操作。</p>
<p>ServerBootstrap.group() 方法:</p>
<pre><code class="language-java">/**
 * Specify the {@link EventLoopGroup} which is used for the parent (acceptor) and the child (client).
 */
@Override
public ServerBootstrap group(EventLoopGroup group) {
    // ① 非主从的 Reactor 模式，一个 group 干两个活
    return group(group, group);
}

/**
 * Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These
 * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link ServerChannel} and
 * {@link Channel}'s.
 */
// 主从模式的 group 配置
public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    // ② 设置 parentGroup 就是我们常说的 boss group 
    super.group(parentGroup);
    if (childGroup == null) {
        throw new NullPointerException(&quot;childGroup&quot;);
    }
    if (this.childGroup != null) {
        throw new IllegalStateException(&quot;childGroup set already&quot;);
    }
    // ③ 设置 childGroup 就是我们常说的 worker group
    this.childGroup = childGroup;
    return this;
}
</code></pre>
<p>先看下步骤 ② 设置了 parentGroup 后的动作。<br>
在 <code>AbstractBootstrap#initAndRegister</code> 初始化中会将后面的 <code>ServerSocketChannel</code> 注册到 parent gorup 上。</p>
<pre><code class="language-java">final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        channel = channelFactory.newChannel();
        // ✅child group在这里初始化
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))
            channel.unsafe().closeForcibly();
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
    }
    // ✅ ServerSocketChannel 在这里注册到 parent group 上
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
}
</code></pre>
<p>接着来看下步骤 ③ 中设置 childGroup 后的操作，如上面贴的代码可以看到在<code>AbstractBootstrap#initAndRegister</code> 同时也初始化了 childGroup 的操作</p>
<pre><code class="language-java">void init(Channel channel) throws Exception {
    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();
    synchronized (options) {
        setChannelOptions(channel, options, logger);
    }

    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();
    synchronized (attrs) {
        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {
            @SuppressWarnings(&quot;unchecked&quot;)
            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();
            channel.attr(key).set(e.getValue());
        }
    }

    ChannelPipeline p = channel.pipeline();
    // ① childGroup 换了一个名字
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));
    }

    p.addLast(new ChannelInitializer&lt;Channel&gt;() {
        @Override
        public void initChannel(final Channel ch) throws Exception {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }

            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // ② 传递给 ServerBootstrapAcceptor
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
</code></pre>
<p>在 ② 中将 childGroup 传递给了 <code>ServerBootstrapAcceptor</code>， 他其实是个 <code>ChannelInboundHandlerAdapter</code>，在他的重写方法<code>ServerBootstrap.ServerBootstrapAcceptor#channelRead</code>中将后续收到的 <code>SocketChannel</code> 注册到 childGroup 上</p>
<pre><code class="language-java">@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    // ① 这个 msg 就是 SocketChannel
    final Channel child = (Channel) msg;

    child.pipeline().addLast(childHandler);

    setChannelOptions(child, childOptions, logger);

    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) {
        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());
    }

    try {
        // ② 注册到 childGroup 上
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
}
</code></pre>
<h2 id="为什么说-netty-的-main-reactor-大多并不能用到一个线程组只能线程组里面的一个">为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个</h2>
<p>因为大多只绑定一个地址，所以就只用到线程组里面的一个<br>
<code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>
<h2 id="netty-给-channel-分配-nio-event-loop-的规则是什么">Netty 给 Channel 分配 NIO event loop 的规则是什么</h2>
<p>对于 NIO 的 EventLoopGroup 的实现是<code>MultithreadEventLoopGroup#register(io.netty.channel.Channel)</code></p>
<pre><code class="language-java">    @Override
    public ChannelFuture register(Channel channel) {
        // 这里的 next() 是个选择器，选择一个 EventExecutor
        return next().register(channel);
    }
</code></pre>
<p>最后是在 <code>EventExecutorChooserFactory</code> 的策略模式中选择一个 <code>EventExecutor</code>，</p>
<pre><code class="language-java">/**
 * Factory that creates new {@link EventExecutorChooser}s.
 */
@UnstableApi
public interface EventExecutorChooserFactory {

    /**
     * Returns a new {@link EventExecutorChooser}.
     */
    EventExecutorChooser newChooser(EventExecutor[] executors);

    /**
     * Chooses the next {@link EventExecutor} to use.
     */
    @UnstableApi
    interface EventExecutorChooser {

        /**
         * Returns the new {@link EventExecutor} to use.
         */
        EventExecutor next();
    }
}
</code></pre>
<p>有两个实现类一个是<code>GenericEventExecutorChooser</code>，另一个是<code>PowerOfTwoEventExecutorChooser</code>，区别在于选择一下个<code>EventExecutor</code>时候，如果是2的幂次，可以直接按为与 <code>&amp;</code> 操作，高效一点。</p>
<h2 id="netty-如何实现多路复用器跨平台的">Netty 如何实现多路复用器跨平台的</h2>
<p>Netty 的 NIO Selector 封装在 <code>NioEventLoopGroup</code> 中</p>
<pre><code class="language-java">public NioEventLoopGroup(int nThreads, Executor executor) {
    this(nThreads, executor, SelectorProvider.provider());
}
</code></pre>
<p>通过 <code>SelectorProvider.provider()</code> 获取相应的Selector。</p>
<pre><code class="language-java">public static SelectorProvider provider() {
    synchronized (lock) {
        if (provider != null)
            return provider;
        return AccessController.doPrivileged(
            new PrivilegedAction&lt;SelectorProvider&gt;() {
                public SelectorProvider run() {
                        // ① 从系统参数从获取 nio selector 的 spi 实现
                        if (loadProviderFromProperty())
                            return provider;
                        // ② 通过 java spi 加载
                        if (loadProviderAsService())
                            return provider;
                        // ③ jdk 实现
                        provider = sun.nio.ch.DefaultSelectorProvider.create();
                        return provider;
                    }
                });
    }
}   
</code></pre>
<p>可以看到，nio 的 selector 获取有三种途径，一般最后就是 sun 的 jdk 中的实现。在 mac 中是 <code>KQueueSelectorProvider</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime 随手记]]></title>
        <id>https://jiangjinxinn.github.io/post/sublime-sui-shou-ji/</id>
        <link href="https://jiangjinxinn.github.io/post/sublime-sui-shou-ji/">
        </link>
        <updated>2019-12-08T08:05:25.000Z</updated>
        <summary type="html"><![CDATA[<p>📃实现一个不会提示保存的 Sublime 随手记</p>
]]></summary>
        <content type="html"><![CDATA[<p>📃实现一个不会提示保存的 Sublime 随手记</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://jiangjinxinn.github.io//post-images/1575792658471.jpg" alt="让人心烦的提示保存" loading="lazy"></figure>
<p>看到上面的提示框，我头很大。平时经常 ctrl n 新建一个页面临时复制一些文本，进行对比或者查看或者临时保存一下，但是在关闭文件的时候会 Sublime 提示你保存，日积月累下来就有点烦了。</p>
<p>所以项找下办法把 Sublime 改成草稿纸，让 ctrl n 新建的页面编辑关闭后不提示保存。</p>
<hr>
<p>Sublime 相关插件搜了一伙儿没有发现，到 Stack Overflow 上搜了下，找到了一些方法。</p>
<p><a href="https://stackoverflow.com/questions/24663013/sublime-text-prompt-to-save-file">sublimetext2 - Sublime Text Prompt to Save File - Stack Overflow</a></p>
<p><a href="https://forum.sublimetext.com/t/request-dont-prompt-to-save-empty-untitled-tabs/685">Request: Don’t prompt to save empty “untitled” tabs - Ideas and Feature Requests - Sublime Forum</a></p>
<hr>
<p>按照 Stack Overflow 上的方法用了下，很好，很满意，新创建的文档会被标记为草稿文件，修改后不会提示保存。修改已存在的文件仍然还有提示保存。</p>
<p>Stack Overflow 上的代码有个地方要改下</p>
<pre><code class="language-python">class SetNewScratchBuffer(sublime_plugin.EventListener):
    def on_new(self, view):
        view.set_scratch(True)

    def on__save(self, view):
        view.set_scratch(False)
</code></pre>
<p><code>on_save</code> 需要改成 <code>on_pre_save</code>。在 <a href="http://www.sublimetext.com/docs/3/api_reference.html#sublime_plugin.EventListener">Sublime API Reference</a> 没有看到 <code>on_save</code> 的信息。</p>
<p>还有个 bug，进程退出启动 Sublime 在默认的 untitled 文件上不会生效，但是不退出进程的话不会有这个问题，不知道是否是 Sublime 的 bug。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stream 生成勾股数]]></title>
        <id>https://jiangjinxinn.github.io/post/stream-sheng-cheng-gou-gu-shu/</id>
        <link href="https://jiangjinxinn.github.io/post/stream-sheng-cheng-gou-gu-shu/">
        </link>
        <updated>2019-11-06T14:01:33.000Z</updated>
        <content type="html"><![CDATA[<p>突然想起去年看的《java8 实战》上的用 Stream 生成勾股数的例子。这里试一下。<br>
关键在于 flatMap 和生成先进行过滤再生成数组，虽然计算了两次开方，但是生成数组的开销更大。</p>
<pre><code class="language-java">import java.util.stream.IntStream;
import java.util.stream.Stream;

class Scratch {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        Stream&lt;int[]&gt; pythagoreanTriple = IntStream.rangeClosed(1, 100).boxed()
                .flatMap(a -&gt; IntStream.rangeClosed(a, 100)
                        .filter(b -&gt; Math.sqrt(a * a + b * b) % 1 == 0)
                        .mapToObj(b -&gt; new int[]{a, b, (int) Math.sqrt(a * a + b * b)}));

        pythagoreanTriple.limit(10).forEach(t -&gt; System.out.println(t[0] + &quot; &quot; + t[1] + &quot; &quot; + t[2]));
        long end = System.currentTimeMillis();
        System.out.println(&quot;total time: &quot; + (end - start) + &quot;\n&quot;);


        long start2 = System.currentTimeMillis();
        Stream&lt;int[]&gt; pythagoreanTriple2 = IntStream.rangeClosed(1, 100).boxed()
                .flatMap(a -&gt; IntStream.rangeClosed(a, 100)
                        .mapToObj(b -&gt; new int[]{a, b, (int) Math.sqrt(a * a + b * b)}))
                        .filter(t -&gt; Math.sqrt(t[2]) % 1 == 0);

        pythagoreanTriple2.limit(10).forEach(t -&gt; System.out.println(t[0] + &quot; &quot; + t[1] + &quot; &quot; + t[2]));
        long end2 = System.currentTimeMillis();
        System.out.println(&quot;total time 2: &quot; + (end2 - start2) + &quot;\n&quot;);
    }
}
</code></pre>
<p>运行的结果</p>
<pre><code>3 4 5
5 12 13
6 8 10
7 24 25
8 15 17
9 12 15
9 40 41
10 24 26
11 60 61
12 16 20
total time: 91

1 1 1
1 4 4
1 9 9
1 16 16
1 25 25
1 36 36
1 49 49
1 64 64
1 81 81
1 100 100
total time 2: 3


Process finished with exit code 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-cn.com ui 修改]]></title>
        <id>https://jiangjinxinn.github.io/post/leetcode-cncom-ui-xiu-gai/</id>
        <link href="https://jiangjinxinn.github.io/post/leetcode-cncom-ui-xiu-gai/">
        </link>
        <updated>2019-11-02T14:51:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="缘起">缘起</h2>
<p>由于看到 leetcode 中国版更新了新的代码编辑器和长久以来在 leetcode 美国版网络有时不顺畅，决定迁到中国版上来。</p>
<p>这时候就碰到了一个问题，中国版改了做题区的 ui，看着感觉非常的难受，不习惯。</p>
<p>美国版的做题区的头部标题区等浑然一体十分自然<br>
<img src="https://jiangjinxinn.github.io//post-images/1572706485835.png" alt="" loading="lazy"></p>
<p>中国版标题区单独上移出来，最重要的是边框与底下部分加了阴影，感觉非常的奇怪。<br>
<img src="https://jiangjinxinn.github.io//post-images/1572706501580.png" alt="" loading="lazy"></p>
<h2 id="动手改一下">动手改一下</h2>
<p>安装 chrome 的扩展插件 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne?hl=zh-CN">Stylus</a></p>
<blockquote>
<p>Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。</p>
</blockquote>
<p>点击编写样式<br>
<img src="https://jiangjinxinn.github.io//post-images/1572707096588.png" alt="" loading="lazy"></p>
<p>添加 css 样式修改下</p>
<pre><code class="language-css">[class*=&quot;HeaderCn&quot;] {
    box-shadow: none
}

[class*=&quot;ant-dropdown-menu-item&quot;] a[href]::after {
    display: none
}

[class*=&quot;NavbarListItem&quot;] a[href]::after {
    display: none
}

[class*=&quot;StyledBanner&quot;] {
    display: none
}
</code></pre>
<h2 id="最终效果">最终效果</h2>
<p>阴影去掉后看起来就舒服多。顺带导航栏上菜单文字后面的 new、hot 也一起处理掉了。<br>
<img src="https://jiangjinxinn.github.io//post-images/1572708099346.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试（2019 年 10 月）]]></title>
        <id>https://jiangjinxinn.github.io/post/mian-shi-2019-nian-10-yue/</id>
        <link href="https://jiangjinxinn.github.io/post/mian-shi-2019-nian-10-yue/">
        </link>
        <updated>2019-11-01T20:07:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="we-公司">we 公司</h2>
<p>10 月 18日</p>
<p>现场面（合计hr 面 2 小时 15 分）</p>
<p>面试官 1:</p>
<ol>
<li>看过哪些源码？</li>
<li>spring bean 生命周期</li>
<li>假设一个类 A 如下，beanFactory 中有两个类型的 Car，beanId 为 carA，carB，下面类中中 Car能否注入成功， 如何让 car 的注入动态化</li>
</ol>
<pre><code>class A {
    @Resource
    private Car someCar;
    
    public someMethod(Car someCar) {
        // sout
    }
}
</code></pre>
<ul>
<li>如何实现一个 LRU 算法</li>
<li>写下递归 n 的阶层</li>
<li>java 中 juc 包下哪些锁是 cas 操作？</li>
<li>synchronized 和可重入锁，JMM、volatile</li>
<li>mysql 根据性别查询不同的用户怎么加索引</li>
<li>mysql 索引</li>
<li>浏览器地址栏输入网址后的过程</li>
<li>聊了下设计模式</li>
<li>聊了下分布式事务</li>
<li>产品经理比较烂怎么办</li>
</ul>
<p>面试官 2：</p>
<ul>
<li>react 的生命周期</li>
<li>webpack 用过没</li>
<li>zookeeper 一致性原理了，zookeeper 核心原理是啥</li>
<li>有没有高并发经验</li>
<li>实现以下代码，模仿ConcurrentHashMap 的computeIfAbsent，但是要求同样的 key 和 mappingFunction同时请求的时候只计算一次，阻塞其他线程</li>
</ul>
<pre><code>public class ConcurrentHashMap {
    public V computeIfAbsent(K key,
            Function&lt;? super K, ? extends V&gt; mappingFunction) {
        /**
        /* 要求 mappingFunction 只计算一次，即同样 key、mappingFunction 
        /* 调用的时候只计算一次,mappingFunction,阻塞另一个线程的调用
        */
    }
}
</code></pre>
<h2 id="yz-公司">yz 公司：</h2>
<p>电话面（约 30 分钟）<br>
2. 为什么要使用分库分表<br>
3. 解释下一条 sql 在分库分表下是怎么查询的<br>
4. 项目中 mq 用来干嘛的<br>
5. mq 消息发送失败怎么处理<br>
6. inodb 索引<br>
7. 隔离级别<br>
8. mvcc，隔离级别怎么实现的<br>
9. 讲下一致性视图<br>
10. 行锁</p>
<h2 id="dd-公司">dd 公司</h2>
<p>电话面（约 1 小时 10 分）</p>
<ol>
<li>用户打分算法 bm5（听不清叫啥了）了解否</li>
<li>并发量有多少，请求量多少</li>
<li>微服务用的什么框架</li>
<li>简历上的校验框架干嘛的，有什么难点</li>
<li>介绍下 dubbo
<ol>
<li>dubbo 主要分层</li>
<li>注册中心挂了还能调用吗</li>
<li>讲述下服务端发起一次请求的过程</li>
<li>序列化机制有哪些</li>
<li>实现 dubbo 扩展机制 spi 要添加哪些类</li>
<li>序列化实现了解吗，为什么选用 hessian</li>
<li>负载均衡机制有哪些</li>
<li>让你来设计一个 rpc 框架，如何设计</li>
</ol>
</li>
<li>mysql 索引、mvcc</li>
<li>并发相关</li>
<li>
<ol>
<li>volatile 语义，使用场景、JMM
<ol>
<li>sychronized 原理、讲述下锁优化、锁膨胀</li>
<li>可重入锁和读写锁</li>
<li>线程池包下主要有哪些类，主要是怎么设计的</li>
<li>线程池中的阻塞队列有哪些</li>
<li>ConcurrentHashMap</li>
</ol>
</li>
</ol>
</li>
<li>有没有碰到过 oom、sql 优化经验</li>
<li>redis
<ol>
<li>事务了解吗</li>
<li>管道操作了解吗</li>
<li>有哪些数据结构</li>
<li>集群</li>
</ol>
</li>
<li>Spring Boot</li>
<li>
<ol>
<li>讲述下你的理解，和 Spring 有哪些区别
<ol>
<li>条件装配怎么实现的</li>
<li>如何实现一个 SpringBoot Starter</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mk-公司">mk 公司</h2>
<p>现场面（合计hr 面约 2 小时 30 分）</p>
<p>面试官 1：</p>
<ul>
<li>Hashmap、ConcurrentHashMap
<ul>
<li>HashMap 并发环境下有什么问题</li>
<li>为什么使用红黑树</li>
<li>红黑树 crud 哪个操作最快</li>
</ul>
</li>
<li>JVM 内存区
<ul>
<li>介绍下常量池</li>
<li>堆中哪些对象可以作为 gc-roots</li>
<li>讲述下类加载过程</li>
</ul>
</li>
<li>Sychronized
<ul>
<li>讲一下锁膨胀如何实现</li>
<li>JMM 内存模型</li>
</ul>
</li>
<li>线程池参数
<ul>
<li>核心线程数与最大线程数的区别</li>
<li>工作队列有哪几种</li>
<li>核心线程数满了以后添加新任务如何处理的</li>
<li>任务拒绝策略有哪些</li>
</ul>
</li>
<li>BeanFactory 与 FactoryBean 的区别</li>
<li>讲一下 mysql 索引
<ul>
<li>联合索引（A,B,C) 查询（B,C) 能否使用索引，为什么？</li>
<li>讲一下mysql 索引使用需要注意的地方</li>
<li>索引底层数据结构</li>
<li>为什么使用 b+树</li>
</ul>
</li>
<li>Dubbo 了解吗
<ul>
<li>负载均衡有哪些策略</li>
<li>一致性 hash 原理</li>
</ul>
</li>
<li>ThreadLocal 使用过吗
<ul>
<li>ThreadLocal 有什么问题？</li>
<li>怎么实现的</li>
</ul>
</li>
<li>Redis
<ul>
<li>String 数据结构是如何实现的</li>
<li>讲下跳表</li>
<li>备份策略</li>
<li>主从同步</li>
</ul>
</li>
</ul>
<p>面试官 2：</p>
<ul>
<li>设计模式
<ul>
<li>设计模式有哪些原则</li>
<li>策略模式</li>
<li>模板方法</li>
</ul>
</li>
<li>数据结构
<ul>
<li>遍历图有几种方式</li>
</ul>
</li>
<li>有没有 oom 过</li>
<li>老年代的对象的年龄都不大是什么原因？如何调优？</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nacos 服务删除失败的问题]]></title>
        <id>https://jiangjinxinn.github.io/post/nacos-fu-wu-shan-chu-shi-bai-de-wen-ti/</id>
        <link href="https://jiangjinxinn.github.io/post/nacos-fu-wu-shan-chu-shi-bai-de-wen-ti/">
        </link>
        <updated>2019-10-14T06:12:22.000Z</updated>
        <content type="html"><![CDATA[<p>在使用 Nacos 作为服务监控的功能的时候出现了一个问题：<br>
删除服务提示失败：<br>
<img src="https://jiangjinxinn.github.io//post-images/1571033820491.png" alt="" loading="lazy"></p>
<p>提示是对应的服务不存在<br>
但是实际上 nacos 的后台管理页面上是存在的，并且我的后台页面上还出现了两个同名的服务，其中一个可以删除成功，另一个会报服务不存在</p>
<p>回忆了下我之前的操作，其中一次在注册服务实例的时候，在服务名后面带上了 <code>@@</code>，加这个原先是为了做服务区分用的，用<code>@@</code> 字符是因为我在 nacos 的源码中看到他们是用 group + <code>@@</code> + serviceName 作为 service 的标识的，想模仿一波，贴近风格。。。</p>
<p>直接到代码中找原因，先找到抛出异常的地方<br>
<code>com.alibaba.nacos.naming.core.ServiceManager#easyRemoveService</code></p>
<pre><code>    public void easyRemoveService(String namespaceId, String serviceName) throws Exception {

        Service service = getService(namespaceId, serviceName);
        if (service == null) {
            // 这里抛出了异常，那么就是，service 为没有查询到
            throw new IllegalArgumentException(&quot;specified service not exist, serviceName : &quot; + serviceName);
        }

        if (!service.allIPs().isEmpty()) {
            throw new IllegalArgumentException(&quot;specified service has instances, serviceName : &quot; + serviceName);
        }

        consistencyService.remove(KeyBuilder.buildServiceMetaKey(namespaceId, serviceName));
    }
</code></pre>
<p>获取 service 的方法在这个接口中<br>
<code>com.alibaba.nacos.naming.core.ServiceManager#getService</code></p>
<pre><code>    public Service getService(String namespaceId, String serviceName) {
        if (serviceMap.get(namespaceId) == null) {
            return null;
        }
        // 这里直接从 map 中查询 key 为serviceName 的 Service
        return chooseServiceMap(namespaceId).get(serviceName);
    }
</code></pre>
<p>可以看到就是到存储了 service 的 concurrentHashMap 中查询 service</p>
<pre><code>    /**
     * Map&lt;namespace, Map&lt;group::serviceName, Service&gt;&gt;
     */
    private Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<p>这里没有查询到，说明 serviceMap 没有存储了相应的键值对数据</p>
<p>serviceMap 中没有存取数据，那控制后台上显示的服务实例数据是哪里来的呢？从 controller 的接口上查看下<br>
<code>com.alibaba.nacos.naming.controllers.CatalogController#listDetail</code></p>
<pre><code>  @RequestMapping(value = &quot;/services&quot;, method = RequestMethod.GET)
    public Object listDetail(HttpServletRequest request) {

        boolean withInstances = Boolean.parseBoolean(WebUtils.optional(request, &quot;withInstances&quot;, &quot;true&quot;));

        if (withInstances) {
            String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID,
                Constants.DEFAULT_NAMESPACE_ID);
            List&lt;ServiceDetailInfo&gt; serviceDetailInfoList = new ArrayList&lt;&gt;();
            int pageNo = Integer.parseInt(WebUtils.required(request, &quot;pageNo&quot;));
            int pageSize = Integer.parseInt(WebUtils.required(request, &quot;pageSize&quot;));
            String keyword = WebUtils.optional(request, &quot;keyword&quot;, StringUtils.EMPTY);

            List&lt;Service&gt; serviceList = new ArrayList&lt;&gt;(8);
            // 控制台上返回带数据来自这里，serviceList 传入serviceManager.getPagedService 方法中被填充了数据
            // 后台界面上有数据，说明这里返回了数据，继续往下看下
            serviceManager.getPagedService(namespaceId, pageNo, pageSize, keyword, StringUtils.EMPTY, serviceList, false);

            for (Service service : serviceList) {
                ServiceDetailInfo serviceDetailInfo = new ServiceDetailInfo();
                // 这里将 Service 的名字进行了转化，就是之前说的，serviceName 是 group + serviceName，这里要把 group 去掉
                serviceDetailInfo.setServiceName(NamingUtils.getServiceName(service.getName()));
                serviceDetailInfo.setGroupName(NamingUtils.getGroupName(service.getName()));
                serviceDetailInfo.setMetadata(service.getMetadata());

                Map&lt;String, ClusterInfo&gt; clusterInfoMap = getStringClusterInfoMap(service);
                serviceDetailInfo.setClusterMap(clusterInfoMap);

                serviceDetailInfoList.add(serviceDetailInfo);
            }

            return serviceDetailInfoList;
        } else {
            return serviceList(request);
        }
    }
</code></pre>
<p>进入到 <code>NamingUtils</code> 中看下具体是如何把 group 去掉，进行 name 转化的。</p>
<pre><code>public class NamingUtils {

    public static String getGroupedName(String serviceName, String groupName) {
        return groupName + Constants.SERVICE_INFO_SPLITER + serviceName;
    }

    public static String getServiceName(String serviceNameWithGroup) {
        if (!serviceNameWithGroup.contains(Constants.SERVICE_INFO_SPLITER)) {
            return serviceNameWithGroup;
        }
        // public static final String SERVICE_INFO_SPLITER = &quot;@@&quot;;
        // 这里是通过直接将字符串按 &quot;@@&quot; 分割，返回数据，所以如果服务的名字带有`@@`，`@@` 会被去掉
        return serviceNameWithGroup.split(Constants.SERVICE_INFO_SPLITER)[1];
    }

    public static String getGroupName(String serviceNameWithGroup) {
        if (!serviceNameWithGroup.contains(Constants.SERVICE_INFO_SPLITER)) {
            return Constants.DEFAULT_GROUP;
        }
        return serviceNameWithGroup.split(Constants.SERVICE_INFO_SPLITER)[0];
    }
}
</code></pre>
<p>从 <code>NamingUtils</code> 可以看出，返回前台界面的时候要将合并的数据，按<code>@@</code> 分割了，获取到服务对应的 group。</p>
<p>最后看下存入 service 信息的时候，是否如所预想的那样，service 的 name 和 group 合并后没有做处理的。<br>
<code>com.alibaba.nacos.naming.core.ServiceManager</code></p>
<pre><code>    public void putService(Service service) {
        if (!serviceMap.containsKey(service.getNamespaceId())) {
            synchronized (putServiceLock) {
                if (!serviceMap.containsKey(service.getNamespaceId())) {
                    serviceMap.put(service.getNamespaceId(), new ConcurrentHashMap&lt;&gt;(16));
                }
            }
        }
        // 可以看到存入 service 的时候，名字没有做处理
        serviceMap.get(service.getNamespaceId()).put(service.getName(), service);
    }
</code></pre>
<h3 id="总结">总结</h3>
<p>nacos 的服务可以分组，如文档所说，模型是 service --&gt; cluster --&gt; insttance，cluster 就是代码中的 group。在实际的代码层面上处理的时候，是将 service 和 cluster 合并成一个属性，用 <code>@@</code> 做分割。</p>
<pre><code class="language-java">/**
 * Service of Nacos server side
 * &lt;p&gt;
 * We introduce a 'service --&gt; cluster --&gt; instance' model, in which service stores a list of clusters,
 * which contain a list of instances.
 * &lt;p&gt;
 * This class inherits from Service in API module and stores some fields that do not have to expose to client.
 *
 * @author nkorange
 */
</code></pre>
<p>这里找到服务删除不掉，原因就是前面所说的，我之前测试的时候，出于一些原因（憨），在注册服务的时候<br>
<code>com.alibaba.nacos.api.naming.NamingService#registerInstance(java.lang.String, com.alibaba.nacos.api.naming.pojo.Instance)</code><br>
注册的服务的名字后面带上了<code>@@</code>，前台展示的时候，<code>@@</code> 由于字符串被去掉了，但是 nacos 上存取服务实例的 map 中的名称中实际上带有我添加的 <code>@@</code>，删除的时候就失败了，因为根据服务 name 查找不到（实际的 name 多了 <code>@@</code> 后缀）。</p>
<p>后台界面上出现两个同名的服务的原因也是因为这个，只是显示的服务名称相同，实际上是两个不同的服务。</p>
<p>为什么 nacos 在返回 service 的时候要将<code>@@</code> 去掉，由前所述因为 group 和 serviceName，返回的时候要把合并的字符，还原回去。</p>
<p>随后查看了下 nacos 中是有做字符检测的，但是正则写的有问题。。<br>
<code>com.alibaba.nacos.naming.core.Service#validate</code>，<br>
<code>com.alibaba.nacos.naming.core.Service#SERVICE_NAME_SYNTAX</code></p>
<pre><code class="language-java">    private static final String SERVICE_NAME_SYNTAX = &quot;[0-9a-zA-Z@\\.:_-]+&quot;;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[雨中泪水独白（Tears in rain monologue）]]></title>
        <id>https://jiangjinxinn.github.io/post/yu-zhong-lei-shui-du-bai-tears-in-rain-monologue/</id>
        <link href="https://jiangjinxinn.github.io/post/yu-zhong-lei-shui-du-bai-tears-in-rain-monologue/">
        </link>
        <updated>2019-10-09T16:18:17.000Z</updated>
        <content type="html"><![CDATA[<p>“	英语：I've seen things you people wouldn't believe. Attack ships on fire off the shoulder of Orion. I watched C-beams glitter in the dark near the Tannhäuser Gate. All those moments will be lost in time, like tears in rain. Time to die.	”</p>
<p>（我曾见过令你们人类难以置信的事情。我看到过战舰在猎户座肩旁熊熊燃烧，也曾看到Ｃ射线在唐怀瑟之门旁的黑暗里闪耀。所有的那些时刻，都将消逝在时光中，一如泪水，消失在雨中。死亡的时刻到了。）</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%9B%A8%E4%B8%AD%E6%B3%AA%E6%B0%B4%E7%8B%AC%E7%99%BD#cite_note-4">wikipedia</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shading-JDBC]]></title>
        <id>https://jiangjinxinn.github.io/post/shading-jdbc/</id>
        <link href="https://jiangjinxinn.github.io/post/shading-jdbc/">
        </link>
        <updated>2019-10-06T13:42:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="流程">流程</h2>
<p>做在 jdbc 层面上</p>
<h2 id="分库分表策略">分库分表策略</h2>
<ul>
<li>垂直</li>
<li>水平</li>
<li>
<ul>
<li>绑定表</li>
</ul>
</li>
</ul>
<h2 id="分片">分片</h2>
<h3 id="新增">新增</h3>
<h2 id="行表达式">行表达式</h2>
<p>实现动机：配置的简化与一体化<br>
语法：使用 Groovy</p>
<p>sql between 时会抛出异常<code>org.springframework.dao.InvalidDataAccessApiUsageException: Inline strategy cannot support range sharding.; nested exception is java.lang.IllegalStateException: Inline strategy cannot support range sharding.</code></p>
<h2 id="分布式-id-生成">分布式 id 生成</h2>
<h3 id="雪花算法默认">雪花算法（默认）</h3>
<p><img src="https://jiangjinxinn.github.io//post-images/1570369804031.png" alt="" loading="lazy"><br>
Sharding-JDBC 中生成后插入数据库中。</p>
<ol>
<li>时钟回拨<br>
服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒 数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为0，可通过属性设置。<br>
https://www.jianshu.com/p/98c202f64652</li>
<li>worker id<br>
重复 worker id 会产生相同的 id https://cloud.tencent.com/developer/article/1074907<br>
worker id 如何配置？</li>
<li>没有并发量的情况下的话，序列号位几乎都是 1，根据路由规则都会路由到一个表中</li>
</ol>
<h2 id="分布式事务">分布式事务</h2>
<p>本地事务：ACID<br>
分布式事务：BASE，通过业务逻辑将互斥操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升</p>
<h3 id="xa">XA</h3>
<p><img src="https://jiangjinxinn.github.io//post-images/1570501311460.png" alt="" loading="lazy"><br>
两阶段事务提交采用X/OPEN组织定义的DTP 模型，通过抽象出来的AP、TM、RM 的概念可以保证事务的强一致性。其中 TM 和 RM 之间采用 XA 协议进行双向通信。与传统的本地事务相比，XA 事务增加了 prepare 阶段，数据库除了被动接受提交指令以外，还可以反向通知调用方事务是否可以被提交。因此 TM可以收集各分支事务的prepare 结果，最后进行原子提交，保证事务的强一致性。<br>
分为准备阶段和提交阶段。每个参与者要么发送失败，要么在本地执行事务，写本地的 redo、undo 日志，但不提交。协调者收到了参与者失败消息或者超时消息，直接给每个参与者发送回滚（rollback）消息，否则发送提交（commit）消息。<br>
需要在多个节点之间进行协调，而各节点对锁资源的释放必须等到事务最终提交的时候。这样比起单阶段提交，会消耗更多时间。事务执行时间延长，意味着锁资源发生冲突的概率增加。</p>
<h3 id="saga">Saga</h3>
<p>多个短时事务组成的长时事务，在分布式场景下，我们把一个 Saga 分布式事务看做一个由多个本地事务组成的事务，每个事务都有一个与之对应的补偿事务。在 Saga 事务执行过程中，某一个出错后，Saga 事务会终止，同时会调用对应的补偿事务完成相关的恢复操作<br>
自动反向补偿。Saga 定义了一个事务中的每个子事务都对应一个反向补偿操作。Saga 事务管理器会根据执行结果生成一张有向无环图，并在执行回滚的时候根据该图一次执行反向补偿操作。Saga 事务管理器只用于何时重试，何时补偿，不负责补偿的内容，补偿的具体操作由开发者自行提供。<br>
Sharding-JDBC 采用了反向 sql 技术，将对数据库的更新操作的 sql 自动生成反向 sql，并交由 <a href="https://github.com/apache/servicecomb-saga-actuator">saga-actuator</a> 执行。</p>
<h3 id="seate">Seate</h3>
<p><a href="https://github.com/seata/seata">Seate</a><br>
<a href="https://shardingsphere.apache.org/document/current/cn/features/transaction/principle/base-transaction-seata/">Sharding-JDBC 的实现原理</a>。整合Seata AT事务时，需要把TM，RM，TC的模型融入到ShardingSphere 分布式事务的SPI的生态中。在数据库资源上，Seata通过对接 DataSource 接口，让JDBC操作可以同 TC 进行 RPC 通信。同样，ShardingSphere 也是面向 DataSource 接口对用户配置的物理 DataSource 进行了聚合，因此把物理 DataSource 二次包装为 Seata 的 DataSource 后，就可以把 Seata AT 事务融入到 ShardingSphere 的分片中。</p>
]]></content>
    </entry>
</feed>