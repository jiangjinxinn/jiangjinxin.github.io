<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiangjinxinn.github.io/</id>
    <title>空调房</title>
    <updated>2020-05-03T20:03:17.205Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiangjinxinn.github.io/"/>
    <link rel="self" href="https://jiangjinxinn.github.io/atom.xml"/>
    <logo>https://jiangjinxinn.github.io/images/avatar.png</logo>
    <icon>https://jiangjinxinn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 空调房</rights>
    <entry>
        <title type="html"><![CDATA[LoadBalance 自动装配]]></title>
        <id>https://jiangjinxinn.github.io/post/loadbalance-zi-dong-zhuang-pei/</id>
        <link href="https://jiangjinxinn.github.io/post/loadbalance-zi-dong-zhuang-pei/">
        </link>
        <updated>2020-05-03T19:36:38.000Z</updated>
        <content type="html"><![CDATA[<p>spring cloud 这块有点厉害，版本升级后包名各种改。。feign、openfeign、netflixfeign 傻傻分不清楚</p>
<p>客户端负载均衡调用就有三种：</p>
<ol>
<li>discovery client</li>
<li>ribbon loadbalanced resttemplate</li>
<li>feignclient</li>
</ol>
<p>虽然这些之间都是有联系的，但搞这么多概念烦不烦啊。。我初来乍到使用 spring cloud 有点懵</p>
<p>原来一直是用第三种 feign client，今天由于想要实现个 feign 的缓存实现，仔细看了下代码</p>
<p>看到第二种 ribbon 的时候，看晕了，记录下收获</p>
<ol>
<li>@Qualifier 的使用</li>
</ol>
<p>注解 <code>@Qualifier</code> 标注了 <code>@Inherited</code>  元注解，并且在其他自定义注解上添加 <code>@Qualifier</code> 注解的时候可以做为 <code>qualifier</code> 使用</p>
<blockquote>
<p>This annotation may be used on a field or parameter as a qualifier for<br>
candidate beans when autowiring. It may also be used to annotate other<br>
custom annotations that can then in turn be used as qualifiers.</p>
</blockquote>
<p><code>@LoadBalanced</code> 注解就被添加了 <code>@Qualifier</code> 注解所以在 <code>LoadBalancerAutoConfiguration</code> 中可以实现只注入被 <code>@LoadBalanced</code> 标记了的 <code>Resttemplatet</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://jiangjinxinn.github.io//post-images/1588535143322.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>自动装配在实现依赖中打开</li>
</ol>
<p>pring-cloud-commons 包下的 <code>org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration</code><br>
并不会自动装配，只有添加了 <code>spring-cloud-starter-loadbalancer</code> 才会自动装配。</p>
<pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
      &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre>
<p>按照 spring cloud 官方的说法，spring cloud common 是抽象实现，在 spring cloud 的不同实现中使用，所以像上述的 loadbalancer 在没有引 loadbalancer 的依赖的时候是不会自动装配的</p>
<blockquote>
<p>Spring Cloud Commons delivers features as two libraries: Spring Cloud Context and Spring Cloud Commons. Spring Cloud Context provides utilities and special services for the ApplicationContext of a Spring Cloud application (bootstrap context, encryption, refresh scope and environment endpoints). Spring Cloud Commons is a set of abstractions and common classes used in different Spring Cloud implementations (eg. Spring Cloud Netflix vs. Spring Cloud Consul).</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring-Cloud-Config]]></title>
        <id>https://jiangjinxinn.github.io/post/spring-cloud-config/</id>
        <link href="https://jiangjinxinn.github.io/post/spring-cloud-config/">
        </link>
        <updated>2020-04-07T01:31:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="如何使用">如何使用</h2>
<h3 id="查看应用配置信息">查看应用配置信息</h3>
<p>config-server对应的域名/ip+下列资源路径</p>
<pre><code>/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties
</code></pre>
<p>**<br>
<strong>说明：</strong><br>
<code>{profile}</code>  的默认是 <code>default</code> <br>
<code>{label}</code> 默认是 <code>master</code> ， <code>{label}</code> 可以是 <code>git branch name</code> 、<code>**commit id**</code> 、 <code>git tag</code> <br>
**注：**填写了不存在的 profile，http 请求是可以成功的，返回时是不会有提示信息的（返回的是 default）</p>
<h3 id="config-sever配置合并覆盖策略">config-sever配置合并覆盖策略</h3>
<h4 id="配置完全覆盖">配置完全覆盖</h4>
<p>可以覆盖所有连接到 config-server 的客户端的配置<br>
server 添加下面的配置后</p>
<pre><code class="language-yaml">spring:
  cloud:
    config:
      server:
        overrides:
          foo: bar
</code></pre>
<p>就可以把 client environment 中 foo 的值设置为 bar</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.2.RELEASE/reference/html/#property-overrides">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.2.RELEASE/reference/html/#property-overrides</a></p>
<h4 id="配置优先级">配置优先级</h4>
<p>config 的核心概念与 spring 的 <code>Environment</code> 和 <code>PropertySource</code> 一致，从 config 获取到的配置都会被整合进 Spring 的 <code>Environment</code> 中。</p>
<p>配置源 <code>PropertySource</code> 的优先级对应于 <code>Environment</code> 中的 <code>PropertiesSourceLists</code> 中的排列顺序，越前面的优先级越高。<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/132176/1586225126977-f58a878f-1097-4a6b-bbff-5ae8734fa08e.png#align=left&amp;display=inline&amp;height=821&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=1642&amp;originWidth=2880&amp;size=1735784&amp;status=done&amp;style=none&amp;width=1440" alt="图片.png" loading="lazy"></p>
<p>spring 应用中可以通过注入拿到 Environment</p>
<pre><code class="language-java">@Autowired
private Environment environment;
</code></pre>
<p>打开了 actuator 的 env 端点后直接到 env 端点上查看</p>
<p>在 spring-cloud-config 的默认配置下<br>
配置源优先级如下：</p>
<ol>
<li>
<p>config-overrides</p>
</li>
<li>
<p>config: application-{profile}.yml</p>
</li>
<li>
<p>config: application.yml</p>
</li>
<li>
<p>config: bootstrap.yml</p>
</li>
<li>
<p>system.properties （-D vm 参数）</p>
</li>
<li>
<p>java --sprinng.config.location 外部文件</p>
</li>
<li>
<p>application-{profile}.yml</p>
</li>
<li>
<p>application.yml</p>
</li>
<li>
<p>bootstrap.yml</p>
</li>
</ol>
<p>-D 的 vm 参数默认会被 config 覆盖，可以通过修改系统变量覆盖策略来修改这个行为</p>
<pre><code class="language-yaml">cloud:
	config:
  	# 是否覆盖系统参数
		override-system-properties: false
</code></pre>
<p>这里需要说明的是，这个覆盖配置只有从 config 拉取到才会生效，本地配置文件配置了这个参数是不会生效的。在使用了 git 作为 config 的后备文件系统的时候，这个参数只有修改在 git 仓库中才会生效</p>
<p>java -jar 外部文件指定启动，要注意区分<br>
--spring.config.location<br>
--spring.config.additional-location</p>
<pre><code>java -jar demo-0.0.1-SNAPSHOT.jar --spring.config.location=classpath:/,file:///Users/x1nn/Desktop/application.yml
</code></pre>
<p>java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</p>
<h4 id="配置合并策略">配置合并策略</h4>
<p>从使用的角度上看，多个配置源的配置像是做了合并覆盖的，云端覆盖了本地配置。<br>
实际上在获取配置的时候是按照配置优先级获取的，所有配置源会按照优先级排序，优先级高的，在获取配置项的时候优先返回，查找不到就到下一个配置源中获取。<br>
对应于 <code>Environment</code> 中的 <code>PropertiesSourceLists</code> <br>
相关代码：</p>
<p><code>org.springframework.core.env.PropertySourcesPropertyResolver#getProperty(java.lang.String, java.lang.Class&lt;T&gt;, boolean)</code> ，从 <code>Environmet</code> 中获取配置信息的时候，会遍历 <code>PropertySourceLists</code> 查找到了相关的配置就会立即返回。<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/132176/1585791557211-a1766dd5-1fa1-4672-913d-bd097e0837e1.png#align=left&amp;display=inline&amp;height=443&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=886&amp;originWidth=1678&amp;size=743094&amp;status=done&amp;style=none&amp;width=839" alt="图片.png" loading="lazy"></p>
<h3 id="加密配置文件">加密配置文件</h3>
<h4 id="server-加入配置开启-client-解密加密文本">server 加入配置，开启 client 解密加密文本</h4>
<p>配置在 bootstrap.yml 中才会生效！</p>
<pre><code class="language-yaml">spring.cloud.config.server.encrypt.enabled=false
</code></pre>
<h4 id="server-client-加入密钥">server、client 加入密钥</h4>
<p>密钥可以通过 -D 参数加入 <code>encrypt.key=${PASSWORD}</code><br>
配置在 bootstrap.yml 中</p>
<pre><code>encrypt.key=some-secret
# encrypt.key=${PASSWORD}
</code></pre>
<h4 id="加密配置文件-2">加密配置文件</h4>
<p>yaml 中<br>
在配置文件中的配置项加上 <code>{cipher}</code> 即可，<strong>yml 中需要加引号</strong></p>
<pre><code class="language-yaml">spring:
  datasource:
    username: dbuser
    password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'
</code></pre>
<p>properties中<br>
注意：properties 中不需要加  <code>''</code></p>
<pre><code>spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ
</code></pre>
<h4 id="server-加密的-endpoint">server 加密的 endpoint</h4>
<p>/encrypt/status：加密功能状态<br>
/key：秘钥信息<br>
/encrypt，post 请求</p>
<p>/decrypt，post 请求</p>
<p><strong>获取加密文本</strong></p>
<pre><code class="language-yaml">$ curl localhost:7050/encrypt -d password
</code></pre>
<p><strong>获取解密文本</strong></p>
<pre><code class="language-yaml">$ curl localhost:7050/decrypt -d fjsakldfjfdkfjlflkjfsdkljflsdjf
</code></pre>
<p>**<br>
**小提示：进行 curl 测试的时候， **<code>**--data-urlencode**</code> 用于正确 url 编码</p>
<p>If you testing with curl, then use &gt; <code>--data-urlencode</code> (instead of &gt; <code>-d</code>) or set an explicit &gt; <code>Content-Type: text/plain</code> to make sure curl encodes the data correctly when there are special characters ('+' is particularly tricky).&gt;</p>
<p>在 server 开启了密码连接后（通过引入 spring-security 实现），post 请求会由于 csrf 防御被拦截，返回 401 错误，上面的请求就不能使用了，解决方法是关闭 spring-security 的 csrf 防御功能。这里就不改了，关闭掉 server 的加解密端点对于安全考虑也是挺好的，改用 <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.2.RELEASE/reference/html/#_encryption_and_decryption">spring cli</a>。</p>
<p><a href="https://github.com/spring-projects/spring-security/issues/7473">issue: https://github.com/spring-projects/spring-security/issues/7473</a></p>
<pre><code class="language-yaml"># 请求不会成功
$ curl user:password@localhost:7050/encrypt -d password -v
</code></pre>
<h3 id="刷新-client-配置-灰度发布"><a href="https://github.com/spring-cloud/spring-cloud-config#spring-cloud-config-client">刷新 client 配置、灰度发布</a></h3>
<p>在一些少数情况下，需要刷新 client 的配置，client 引入 <code>spring-boot-actuator-starter</code>  即可<br>
client 添加 actuator 的配置，将 /refresh 端点暴露出来</p>
<pre><code class="language-yaml">management:
  endpoints:
    enabled-by-default: true
    web:
      exposure:
      # 这里按需配置
        include: health,info,refresh
      base-path: /actuator
  endpoint:
    health:
      show-details: always
</code></pre>
<p>在需要刷新配置的类上添加 <code>@RefreshScope</code> 注解</p>
<pre><code class="language-java">package com.wekj.ground.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.core.env.Environment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;

@RestController
@RefreshScope
public class TestController {
    @Autowired
    private Environment environment;

    @Value(&quot;${foo:bar}&quot;)
    private String foo;

    @GetMapping(&quot;foo&quot;)
    public String getFoo() {
        return foo;
    }
}
</code></pre>
<p>调用 actuator 端点进行刷新：</p>
<pre><code>$ curl -X POST http://localhost:7010/actuator/refresh
{&quot;code&quot;:1,&quot;msg&quot;:&quot;操作成功!&quot;,&quot;data&quot;:[&quot;foo&quot;]}
</code></pre>
<p>调用 /refresh 刷新 bean 的时候，会将需要刷新的 bean 销毁掉，下次从 bean factory 重新获取 bean 时，重新初始化一遍。<br>
依赖了可刷新 bean 的 bean 注入的是刷新 bean 的代理对象，所以不会受到影响。</p>
<h3 id="多配置管理">多配置管理</h3>
<h4 id="label-特点">label 特点</h4>
<p><strong>label 应该理解成配置的版本控制，指定 label 就是指定配置的哪个版本</strong><br>
label 可以指定多个 label，在指定多个 label 的时候，会一个个尝试获取相对应 label 的配置，直到一个 label 成功为止，这在开发 feature 分支时比较有用。<br>
下面这个例子会先查询 myfeature label 是否存在，存在的话拉取到配置就会停止，develop  的配置会被抛弃，如果 myfeature 不存在，就会获取 develop label 的配置。</p>
<pre><code>spring.cloud.config.label=myfeature,develop
</code></pre>
<h4 id="多配置文件方案">多配置文件方案</h4>
<p>需要指定多个 profile 的话这样配置到 bootstrap.yml 中</p>
<pre><code class="language-yaml">spring: 
  cloud:
    config:
      uri: http://localhost:7050
      label: local
      username: user
      password: password
      allowOverride: true
      overrideNone: true
      overrideSystemProperties: false
      # 配置激活的 profile
      profile: default,local
</code></pre>
<p>应用启动的时候，会将 bootstrap.yml profile 中指定的配置拉取下来，再结合本地的配置。<br>
应用启动的配置来源于两个，一个是获取到的云端配置，一个是本地配置，两次获取都可以指定需要获取的 profile，不会覆盖。<br>
云端无法覆盖应用启动指定的 profile，只能获取 spring.cloud.config.profile 对应的配置。</p>
<figure data-type="image" tabindex="1"><img src="https://jiangjinxinn.github.io//post-images/1587880963457.jpg" alt="" loading="lazy"></figure>
<h3 id="配置缓存">配置缓存</h3>
<p><a href="">默认 server 端是不会缓存获取到的配置的</a>，client 也不会有缓存</p>
<h4 id="server-端如何缓存配置">server 端如何缓存配置</h4>
<p>client 到 sever 获取配置的时候，server 会从 git 仓库获取，server 默认是每次获取配置都从 git 仓库获取，可以修改配置做到 server 缓存配置功能</p>
<pre><code class="language-yaml"># 单位 s，默认为0，表示 server 每次获取客户端请求的配置都从远程 git 仓库获取
spring.cloud.config.server.git.refreshRate=0
</code></pre>
<p>server 是否刷新缓存代码：<br>
<code>org.springframework.cloud.config.server.environment.JGitEnvironmentRepository#refresh</code></p>
<pre><code># server 缓存存放的位置
spring.cloud.config.server.git.basedir=
</code></pre>
<p>server 的缓存会在 server 关闭的时候删除掉 <code>org.springframework.cloud.config.server.support.AbstractScmAccessor#createBaseDir</code> <br>
<strong>在 server 启动后，git 远程仓库连接不上了，这时会使用本地缓存。</strong></p>
<h4 id="客户端缓存配置">客户端缓存配置</h4>
<p>client 启动的时候会将 server 获取到配置保存到内存中，后续从 server 获取配置的时候，不会使用&quot;缓存&quot;在内存中的配置。</p>
<p>相关代码在：<br>
<code>org.springframework.cloud.config.client.ConfigServicePropertySourceLocator#locate</code><br>
<code>org.springframework.cloud.config.client.ConfigServicePropertySourceLocator#getRemoteEnvironment</code><br>
可以在 <code>getRemoteEnvironment</code> 这个方法中看到每次获取配置都是发起 http 请求到 server 的，获取不到配置的话，再根据是否配置了快速失败抛出异常。<br>
<img src="https://jiangjinxinn.github.io//post-images/1587880251548.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://jiangjinxinn.github.io//post-images/1587880212590.jpg" alt="" loading="lazy"></figure>
<h3 id="本地开发方案">本地开发方案</h3>
<h4 id="本地开发方案-2">本地开发方案</h4>
<p>1、需要修改配置的话，在配置仓库拉 feature 同名分支<br>
2、验证无误后提交merger request合并到对应环境</p>
<h4 id="发布流程">发布流程</h4>
<p>建议：本地开发可以只留下一个 bootstrap.yml，application.yml 都去掉</p>
<h3 id="server高可用-安全性">server高可用、安全性</h3>
<h4 id="client-健康检查">client 健康检查</h4>
<p>检测是否能连接 sever 成功，默打开，可以不打开，因为动态刷新需求的很少。应用启动成功后，server down 掉也不影响应用。</p>
<pre><code>health.config.enabled=false
# 健康检查周期默认 5 分钟，单位 ms
health.config.time-to-live=milliseconds
</code></pre>
<h4 id="client-启动快速失败">client 启动快速失败</h4>
<p><strong>强烈建议打开：</strong></p>
<pre><code>spring.cloud.config.fail-fast=true
</code></pre>
<p>打开后客户端快速失败后，应用启动时，如果连接不上 server 就会停止启动，默认是没有打开的，连接失败只会打印 warn 日志。<br>
在应用启动成功后，如果 server 挂了，应用是不会受到快速失败影响的。在刷新配置的时候会提示 server down 了。</p>
<h4 id="client-密码连接-server">client 密码连接 server</h4>
<p>server 引入 <code>spring-security</code> 的 starter</p>
<pre><code># 不配置的话默认是 user
spring.security.user.name
# 不配置的话会随机生成一个密码
spring.security.user.password
</code></pre>
<pre><code>$ curl user:password@localhost:7050/ground/default/master
</code></pre>
<p>config-client 把密码配置到 spring.cloud.config 下面</p>
<pre><code class="language-yaml">spring:
  application:
    name: ground
  cloud:
    config:
      uri: http://localhost:7050
      label: local
      fail-fast: true
      username: user
      password: password
</code></pre>
<ol>
<li>如果连接 server 的密码错误，启动报错不会提示密码错误，而是下面的这个错误（打开快速失败很有必要）</li>
</ol>
<pre><code>java.lang.IllegalStateException: Could not locate PropertySource and the fail fast property is set, failing
	at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator.locate(ConfigServicePropertySourceLocator.java:148) ~[spring-cloud-config-client-2.2.2.RELEASE.jar:2.2.2.RELEASE]
	at org.springframework.cloud.bootstrap.config.PropertySourceLocator.locateCollection(PropertySourceLocator.java:52) ~[spring-cloud-context-2.2.2.RELEASE.jar:2.2.2.RELEASE]
	at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator.locateCollection(ConfigServicePropertySourceLocator.java:163) ~[spring-cloud-config-client-2.2.2.RELEASE.jar:2.2.2.RELEASE]
	at org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration.initialize(PropertySourceBootstrapConfiguration.java:97) ~[spring-cloud-context-2.2.2.RELEASE.jar:2.2.2.RELEASE]
</code></pre>
<h4 id="server-启动配置来自-config">server 启动配置来自 config</h4>
<p>如果选择内嵌在 springboot 应用中启动 server，可以使 server 的配置也从 git 拉取<br>
<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.2.RELEASE/reference/html/#_embedding_the_config_server">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.2.RELEASE/reference/html/#_embedding_the_config_server</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Netty 增强写 FlushConsolidationHandler]]></title>
        <id>https://jiangjinxinn.github.io/post/netty-zeng-qiang-xie/</id>
        <link href="https://jiangjinxinn.github.io/post/netty-zeng-qiang-xie/">
        </link>
        <updated>2020-02-06T06:33:13.000Z</updated>
        <content type="html"><![CDATA[<p>如果追求吞吐量，可以不用 ctx.writeAndFlush()，这种写数据是在每次 write 后都立即 flush，加急写数据。</p>
<p>在 FlushConsolidationHandler 类的注释上有说明这个问题：</p>
<blockquote>
<p>Flush operations are generally speaking expensive as these may trigger a syscall on the transport level. Thus it is in most cases (where write latency can be traded with throughput) a good idea to try to minimize flush operations as much as possible.</p>
</blockquote>
<p><strong>我们可以通过添加一个增强写的 Netty 的 FlushConsolidationHandler来处理这个事情，这个 Handler 有一个参数 explicitFlushAfterFlushes 可以控制拦截几次 flush 后才进行真正的 flush操作。</strong></p>
<p>这里提到 FlushConsolidationHandler 可以拦截，那么不用想，肯定是继承了 ChannelDuplexHandler。</p>
<p>这里不知道大家有没有一个问题，在添加 FlushConsolidationHandler 设定了 explicitFlushAfterFlushes 之后看，如果 flush 次数不够难道就一直不 flush 出去了，需要等到后边一次请求进来的出站事件到来后 flush 够了才能写吗？</p>
<p>这个问题肯定不是的，如果是的话就是个严重的缺陷的。</p>
<p>这个问题我们通过查看 FlushConsolidationHandler 源码来说明下</p>
<p>关键点在 flush 方法上，需要说明的是在任意一个 ctx 上执行 flush 的时候，会根据 pipeline 上设置的 ChannelHandlerContext，寻找下一个 outBoundHandler 传递下去，到 FlushConsolidationHandler 时候就会被拦截下来</p>
<pre><code>@Override
public void flush(ChannelHandlerContext ctx) throws Exception {
    if (readInProgress) {
        // If there is still a read in progress we are sure we will see a channelReadComplete(...) call. Thus
        // we only need to flush if we reach the explicitFlushAfterFlushes limit.
        if (++flushPendingCount == explicitFlushAfterFlushes) {
            flushNow(ctx);
        }
    } else if (consolidateWhenNoReadInProgress) {
        // Flush immediately if we reach the threshold, otherwise schedule
        if (++flushPendingCount == explicitFlushAfterFlushes) {
            flushNow(ctx);
        } else {
            scheduleFlush(ctx);
        }
    } else {
        // Always flush directly
        flushNow(ctx);
    }
}
</code></pre>
<p>Netty 源码上的注解已经很好的说明了，有一个变量 readInProgress 标识是否正在读（即读事件未结束），这里我们先不查看 consolidateWhenNoReadInProgress 这个分支。如果 readInProgress 标记正在读 FlushConsolidationHandler 就会进行继续进行拦截，直到 flush 次数满足了后才会进行最后的 flush，读事件已经结束的话直接调用最后的 flush</p>
<p>这就解答了上面的问题，如果 flush 次数不够，但是读事件已经结束了，依然会进行 flush。</p>
<p>这时不知道大家有没有一个问题，那就是感觉这个 FlushConsolidationHandler 没什么用，因为作为开发者，我只要不调用 ctx.writeAndFlush() 即可，只调用 ctx.write ()，然后再最后 flush 掉。</p>
<p>对的，这个在 Netty 的官方 demo 中就是这样实例的，只在读事件结束后才进行 ctx.flush()</p>
<pre><code>/**
 * Handler implementation for the echo server.
 */
@Sharable
public class EchoServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre>
<p>那么这个 FlushConsolidationHandler 是怎么使用的呢？</p>
<p>这个 FlushConsolidationHandler 主要是在异步写（在 handler 上添加了线程池）的时候使用的，拦截多次异步写即通过前面 consolidateWhenNoReadInProgress 来控制，而且为了防止异步写未执行够设定的 explicitFlushAfterFlushes ，会添加一个 future 来进行调用最后的 flush</p>
<p>因为 Netty 的线程模型是一个 pipeline 绑定一个同一个 eventLoop，所以不会有并发执行的问题，同时不会有多个读事件在一个 pipeline 上发生，在同一次读事件未结束之前（未调用channelReadComplete 之前） 都会是 readInProgress true，保证 flush 的执行可以在读事件处理完后进行，如果读事件结束了，就可以直接 flush 出去。</p>
<p>但是在一个 pipeline 上的读事件完成了不带表真正的读事件完成了，如果读事件是在另起一个线程池的业务线程中执行的，虽然当前 pipelin 上的读事件已经返回了，但是可能还没有调用 writeAndFlush。<br>
consolidateWhenNoReadInProgress 参数的存在就是为了应对这种问题。</p>
<p>看下实例的异步写情况：</p>
<pre><code>UnorderedThreadPoolEventExecutor eventExecutors = new UnorderedThreadPoolEventExecutor(10);
try {
    serverBootstrap.group(boss, worker)
            .handler(new LoggingHandler(LogLevel.INFO))
            .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {
                protected void initChannel(NioSocketChannel ch) throws Exception {
                    ChannelPipeline pipeline = ch.pipeline();

                    pipeline.addLast(new ServerIdleCheckHandler());
                    pipeline.addLast(&quot;frameDecoder&quot;, new FrameDecoder());
                    pipeline.addLast(&quot;frameEncoder&quot;, new FrameEncoder());

                    pipeline.addLast(&quot;protocolEncoder&quot;, new ProtocolEncoder());
                    pipeline.addLast(&quot;protocolDecoder&quot;, new ProtocolDecoder());


                    pipeline.addLast(new LoggingHandler(LogLevel.INFO));
                    pipeline.addLast(eventExecutors, &quot;serviceHandler&quot;, serviceDispatchHandler);

                }
            });
    ChannelFuture sync = serverBootstrap.bind(8098).sync();
</code></pre>
<p>pipeline.addLast(eventExecutors, &quot;serviceHandler&quot;, serviceDispatchHandler); 关键在这行代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# 2019]]></title>
        <id>https://jiangjinxinn.github.io/post/2019/</id>
        <link href="https://jiangjinxinn.github.io/post/2019/">
        </link>
        <updated>2020-01-25T07:33:16.000Z</updated>
        <content type="html"><![CDATA[<p>网上看了些年终总结，大多数还是打广告性质的，讲述下自己这一年干了啥，作为论述下自己很牛逼的证据，确实，一眼看下来感觉他们输出真的牛逼，暗暗和自己对比了下，心里泛起了嘀咕，咋人与人之间差距这么大呢?</p>
<p>我在以前看到自己写的笔记和日记时都会想要删掉它们，心里还要疑问下，这个傻逼是我？慢慢的体会到时间飞逝，留下来一些记录也挺有意思的，傻逼的自己也是自己，所以有了这篇总结。</p>
<hr>
<p>想来从 2018 年 6 月毕业至今马上就要工作两年了，和每次回想以前的事一样，都会感叹时间过的之快。</p>
<p>感觉现在技术水平算是入了个门吧，从刚开始来公司的时候，idea 用不来，上网查教程到现在上网查看面试题，学习的过程就是这个样子吧。</p>
<p>想起第一次看到组长代码里用 BeanUtils 的 copyProperties 方法，第一次看到同事用 ApplicationContextAware 时候的惊讶，看到同事封装 react 写个类的时候，看到公司内部使用的框架是主管写的时候，我小小的内心都被震撼了。有一次听到隔壁组的同事说分布式锁的时候，更是浑身抖擞了一下，太牛逼了，心里不断的发出感叹。</p>
<p>然后就是稳步进行中的搬砖事业，被 react 前端吊打的过程，从 java 基础开始恶补知识。</p>
<p>印象更深的就是今年年中的时候组里来了个实习生，想下同期的自己在干啥，更加感觉自己太菜了，还要加把劲，但总又感觉有点奇怪，算来也 25 岁了，咋还要每天学习。。</p>
<p>年中以后换了个组，开始写点超出我水平的代码，写都写不来，只能去抄代码。。看 nacos 代码的时候，被代码里的心跳连接惊艳了，顿时感觉自己之前不知道在干啥，憨憨的一样。好在虽然项目超时了，组长也只能背后嘀咕下超时了超时了，也不会说啥。。。</p>
<p>慢慢心里觉得公司 low 的感觉越来越强烈，code review 都没有啊，还要老是强调代码规范，同事 maven 打个 jar 包都老是翻车坑我，什么情况啊。公司的文化也越来越熟悉，熟悉后随之而来的是有点失望。</p>
<p>这一年绩效也不好看，心态时常爆炸。好在现在能稳的住了。</p>
<p>我希望这里就算做是对事实的描述，而不是抱怨，毕竟抱怨不能解决问题，也没人会喜欢负能量。但这里还是会如实的记录下我后面对公司的看法，不做修饰。</p>
<hr>
<p>总的来说，我觉得我还是幸运的，在公司的时候主要还是在学习，有时干些超出自己水平的事。更难能可贵的是心态得到了锻炼，这种财富还是更加珍贵的。</p>
<p>想起主管对我说，有些东西只有你在一家公司待的足够久才会明白。我觉得我明白了一些了，但我不能确定是不是他所说明白的东西。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Netty 对 Reactor 模式常见的疑问]]></title>
        <id>https://jiangjinxinn.github.io/post/netty-dui-reactor-mo-shi-chang-jian-de-yi-wen/</id>
        <link href="https://jiangjinxinn.github.io/post/netty-dui-reactor-mo-shi-chang-jian-de-yi-wen/">
        </link>
        <updated>2019-12-15T12:34:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="netty-如何支持主从-reactor-模式">Netty 如何支持主从 Reactor 模式</h2>
<p>简单来说就是将 两种 channel 注册到两种 EventLoopGroup上。<br>
主要的逻辑在 引导类 <code>ServerBootstrap</code> 的 group() 中配置了 BossGroup 和 WorkGroup，会在后面 register() 完成初始化操作。</p>
<p>ServerBootstrap.group() 方法:</p>
<pre><code class="language-java">/**
 * Specify the {@link EventLoopGroup} which is used for the parent (acceptor) and the child (client).
 */
@Override
public ServerBootstrap group(EventLoopGroup group) {
    // ① 非主从的 Reactor 模式，一个 group 干两个活
    return group(group, group);
}

/**
 * Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These
 * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link ServerChannel} and
 * {@link Channel}'s.
 */
// 主从模式的 group 配置
public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    // ② 设置 parentGroup 就是我们常说的 boss group 
    super.group(parentGroup);
    if (childGroup == null) {
        throw new NullPointerException(&quot;childGroup&quot;);
    }
    if (this.childGroup != null) {
        throw new IllegalStateException(&quot;childGroup set already&quot;);
    }
    // ③ 设置 childGroup 就是我们常说的 worker group
    this.childGroup = childGroup;
    return this;
}
</code></pre>
<p>先看下步骤 ② 设置了 parentGroup 后的动作。<br>
在 <code>AbstractBootstrap#initAndRegister</code> 初始化中会将后面的 <code>ServerSocketChannel</code> 注册到 parent gorup 上。</p>
<pre><code class="language-java">final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        channel = channelFactory.newChannel();
        // ✅child group在这里初始化
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))
            channel.unsafe().closeForcibly();
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
    }
    // ✅ ServerSocketChannel 在这里注册到 parent group 上
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
}
</code></pre>
<p>接着来看下步骤 ③ 中设置 childGroup 后的操作，如上面贴的代码可以看到在<code>AbstractBootstrap#initAndRegister</code> 同时也初始化了 childGroup 的操作</p>
<pre><code class="language-java">void init(Channel channel) throws Exception {
    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();
    synchronized (options) {
        setChannelOptions(channel, options, logger);
    }

    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();
    synchronized (attrs) {
        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {
            @SuppressWarnings(&quot;unchecked&quot;)
            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();
            channel.attr(key).set(e.getValue());
        }
    }

    ChannelPipeline p = channel.pipeline();
    // ① childGroup 换了一个名字
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));
    }

    p.addLast(new ChannelInitializer&lt;Channel&gt;() {
        @Override
        public void initChannel(final Channel ch) throws Exception {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }

            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // ② 传递给 ServerBootstrapAcceptor
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
</code></pre>
<p>在 ② 中将 childGroup 传递给了 <code>ServerBootstrapAcceptor</code>， 他其实是个 <code>ChannelInboundHandlerAdapter</code>，在他的重写方法<code>ServerBootstrap.ServerBootstrapAcceptor#channelRead</code>中将后续收到的 <code>SocketChannel</code> 注册到 childGroup 上</p>
<pre><code class="language-java">@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    // ① 这个 msg 就是 SocketChannel
    final Channel child = (Channel) msg;

    child.pipeline().addLast(childHandler);

    setChannelOptions(child, childOptions, logger);

    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) {
        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());
    }

    try {
        // ② 注册到 childGroup 上
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
}
</code></pre>
<h2 id="为什么说-netty-的-main-reactor-大多并不能用到一个线程组只能线程组里面的一个">为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个</h2>
<p>因为大多只绑定一个地址，所以就只用到线程组里面的一个<br>
<code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>
<h2 id="netty-给-channel-分配-nio-event-loop-的规则是什么">Netty 给 Channel 分配 NIO event loop 的规则是什么</h2>
<p>对于 NIO 的 EventLoopGroup 的实现是<code>MultithreadEventLoopGroup#register(io.netty.channel.Channel)</code></p>
<pre><code class="language-java">    @Override
    public ChannelFuture register(Channel channel) {
        // 这里的 next() 是个选择器，选择一个 EventExecutor
        return next().register(channel);
    }
</code></pre>
<p>最后是在 <code>EventExecutorChooserFactory</code> 的策略模式中选择一个 <code>EventExecutor</code>，</p>
<pre><code class="language-java">/**
 * Factory that creates new {@link EventExecutorChooser}s.
 */
@UnstableApi
public interface EventExecutorChooserFactory {

    /**
     * Returns a new {@link EventExecutorChooser}.
     */
    EventExecutorChooser newChooser(EventExecutor[] executors);

    /**
     * Chooses the next {@link EventExecutor} to use.
     */
    @UnstableApi
    interface EventExecutorChooser {

        /**
         * Returns the new {@link EventExecutor} to use.
         */
        EventExecutor next();
    }
}
</code></pre>
<p>有两个实现类一个是<code>GenericEventExecutorChooser</code>，另一个是<code>PowerOfTwoEventExecutorChooser</code>，区别在于选择一下个<code>EventExecutor</code>时候，如果是2的幂次，可以直接按为与 <code>&amp;</code> 操作，高效一点。</p>
<h2 id="netty-如何实现多路复用器跨平台的">Netty 如何实现多路复用器跨平台的</h2>
<p>Netty 的 NIO Selector 封装在 <code>NioEventLoopGroup</code> 中</p>
<pre><code class="language-java">public NioEventLoopGroup(int nThreads, Executor executor) {
    this(nThreads, executor, SelectorProvider.provider());
}
</code></pre>
<p>通过 <code>SelectorProvider.provider()</code> 获取相应的Selector。</p>
<pre><code class="language-java">public static SelectorProvider provider() {
    synchronized (lock) {
        if (provider != null)
            return provider;
        return AccessController.doPrivileged(
            new PrivilegedAction&lt;SelectorProvider&gt;() {
                public SelectorProvider run() {
                        // ① 从系统参数从获取 nio selector 的 spi 实现
                        if (loadProviderFromProperty())
                            return provider;
                        // ② 通过 java spi 加载
                        if (loadProviderAsService())
                            return provider;
                        // ③ jdk 实现
                        provider = sun.nio.ch.DefaultSelectorProvider.create();
                        return provider;
                    }
                });
    }
}   
</code></pre>
<p>可以看到，nio 的 selector 获取有三种途径，一般最后就是 sun 的 jdk 中的实现。在 mac 中是 <code>KQueueSelectorProvider</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime 随手记]]></title>
        <id>https://jiangjinxinn.github.io/post/sublime-sui-shou-ji/</id>
        <link href="https://jiangjinxinn.github.io/post/sublime-sui-shou-ji/">
        </link>
        <updated>2019-12-08T08:05:25.000Z</updated>
        <summary type="html"><![CDATA[<p>📃实现一个不会提示保存的 Sublime 随手记</p>
]]></summary>
        <content type="html"><![CDATA[<p>📃实现一个不会提示保存的 Sublime 随手记</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://jiangjinxinn.github.io//post-images/1575792658471.jpg" alt="让人心烦的提示保存" loading="lazy"></figure>
<p>看到上面的提示框，我头很大。平时经常 ctrl + n 新建一个页面复制一些文本，进行对比或者查看，但是在关闭文件的时候会 Sublime 提示你保存，日积月累下来就有点烦了。</p>
<p>所以项找下办法把 Sublime 改成草稿纸，让 ctrl + n 新建的页面编辑关闭后不提示保存。</p>
<hr>
<p>Sublime 相关插件搜了一伙儿没有发现，到 Stack Overflow 上搜了下，找到了一些方法。</p>
<p><a href="https://stackoverflow.com/questions/24663013/sublime-text-prompt-to-save-file">sublimetext2 - Sublime Text Prompt to Save File - Stack Overflow</a></p>
<p><a href="https://forum.sublimetext.com/t/request-dont-prompt-to-save-empty-untitled-tabs/685">Request: Don’t prompt to save empty “untitled” tabs - Ideas and Feature Requests - Sublime Forum</a></p>
<hr>
<p>按照 Stack Overflow 上的方法用了下，很好，很满意，新创建的文档会被标记为草稿文件，修改后不会提示保存。修改已存在的文件仍然还有提示保存。</p>
<p>Stack Overflow 上的代码有个地方要改下</p>
<pre><code class="language-python">class SetNewScratchBuffer(sublime_plugin.EventListener):
    def on_new(self, view):
        view.set_scratch(True)

    def on__save(self, view):
        view.set_scratch(False)
</code></pre>
<p><code>on_save</code> 需要改成 <code>on_pre_save</code>。在 <a href="http://www.sublimetext.com/docs/3/api_reference.html#sublime_plugin.EventListener">Sublime API Reference</a> 没有看到 <code>on_save</code> 的信息。</p>
<p>还有个 bug，进程退出启动 Sublime 在默认的 untitled 文件上不会生效，但是不退出进程的话不会有这个问题，不知道是否是 Sublime 的 bug。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stream 生成勾股数]]></title>
        <id>https://jiangjinxinn.github.io/post/stream-sheng-cheng-gou-gu-shu/</id>
        <link href="https://jiangjinxinn.github.io/post/stream-sheng-cheng-gou-gu-shu/">
        </link>
        <updated>2019-11-06T14:01:33.000Z</updated>
        <content type="html"><![CDATA[<p>突然想起去年看的《java8 实战》上的用 Stream 生成勾股数的例子。这里试一下。<br>
关键在于 flatMap 和生成先进行过滤再生成数组，虽然计算了两次开方，但是生成数组的开销更大。</p>
<pre><code class="language-java">import java.util.stream.IntStream;
import java.util.stream.Stream;

class Scratch {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        Stream&lt;int[]&gt; pythagoreanTriple = IntStream.rangeClosed(1, 100).boxed()
                .flatMap(a -&gt; IntStream.rangeClosed(a, 100)
                        .filter(b -&gt; Math.sqrt(a * a + b * b) % 1 == 0)
                        .mapToObj(b -&gt; new int[]{a, b, (int) Math.sqrt(a * a + b * b)}));

        pythagoreanTriple.limit(10).forEach(t -&gt; System.out.println(t[0] + &quot; &quot; + t[1] + &quot; &quot; + t[2]));
        long end = System.currentTimeMillis();
        System.out.println(&quot;total time: &quot; + (end - start) + &quot;\n&quot;);


        long start2 = System.currentTimeMillis();
        Stream&lt;int[]&gt; pythagoreanTriple2 = IntStream.rangeClosed(1, 100).boxed()
                .flatMap(a -&gt; IntStream.rangeClosed(a, 100)
                        .mapToObj(b -&gt; new int[]{a, b, (int) Math.sqrt(a * a + b * b)}))
                        .filter(t -&gt; Math.sqrt(t[2]) % 1 == 0);

        pythagoreanTriple2.limit(10).forEach(t -&gt; System.out.println(t[0] + &quot; &quot; + t[1] + &quot; &quot; + t[2]));
        long end2 = System.currentTimeMillis();
        System.out.println(&quot;total time 2: &quot; + (end2 - start2) + &quot;\n&quot;);
    }
}
</code></pre>
<p>运行的结果</p>
<pre><code>3 4 5
5 12 13
6 8 10
7 24 25
8 15 17
9 12 15
9 40 41
10 24 26
11 60 61
12 16 20
total time: 91

1 1 1
1 4 4
1 9 9
1 16 16
1 25 25
1 36 36
1 49 49
1 64 64
1 81 81
1 100 100
total time 2: 3


Process finished with exit code 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-cn.com ui 修改]]></title>
        <id>https://jiangjinxinn.github.io/post/leetcode-cncom-ui-xiu-gai/</id>
        <link href="https://jiangjinxinn.github.io/post/leetcode-cncom-ui-xiu-gai/">
        </link>
        <updated>2019-11-02T14:51:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="缘起">缘起</h2>
<p>由于看到 leetcode 中国版更新了新的代码编辑器和长久以来在 leetcode 美国版网络有时不顺畅，决定迁到中国版上来。</p>
<p>这时候就碰到了一个问题，中国版改了做题区的 ui，看着感觉非常的难受，不习惯。</p>
<p>美国版的做题区的头部标题区等浑然一体十分自然<br>
<img src="https://jiangjinxinn.github.io//post-images/1572706485835.png" alt="" loading="lazy"></p>
<p>中国版标题区单独上移出来，最重要的是边框与底下部分加了阴影，感觉非常的奇怪。<br>
<img src="https://jiangjinxinn.github.io//post-images/1572706501580.png" alt="" loading="lazy"></p>
<h2 id="动手改一下">动手改一下</h2>
<p>安装 chrome 的扩展插件 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne?hl=zh-CN">Stylus</a></p>
<blockquote>
<p>Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。</p>
</blockquote>
<p>点击编写样式<br>
<img src="https://jiangjinxinn.github.io//post-images/1572707096588.png" alt="" loading="lazy"></p>
<p>添加 css 样式修改下</p>
<pre><code class="language-css">[class*=&quot;HeaderCn&quot;] {
    box-shadow: none
}

[class*=&quot;ant-dropdown-menu-item&quot;] a[href]::after {
    display: none
}

[class*=&quot;NavbarListItem&quot;] a[href]::after {
    display: none
}

[class*=&quot;StyledBanner&quot;] {
    display: none
}
</code></pre>
<h2 id="最终效果">最终效果</h2>
<p>阴影去掉后看起来就舒服多。顺带导航栏上菜单文字后面的 new、hot 也一起处理掉了。<br>
<img src="https://jiangjinxinn.github.io//post-images/1572708099346.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试（2019 年 10 月）]]></title>
        <id>https://jiangjinxinn.github.io/post/mian-shi-2019-nian-10-yue/</id>
        <link href="https://jiangjinxinn.github.io/post/mian-shi-2019-nian-10-yue/">
        </link>
        <updated>2019-11-01T20:07:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="we-公司">we 公司</h2>
<p>10 月 18日</p>
<p>现场面（合计hr 面 2 小时 15 分）</p>
<p>面试官 1:</p>
<ol>
<li>看过哪些源码？</li>
<li>spring bean 生命周期</li>
<li>假设一个类 A 如下，beanFactory 中有两个类型的 Car，beanId 为 carA，carB，下面类中中 Car能否注入成功， 如何让 car 的注入动态化</li>
</ol>
<pre><code>class A {
    @Resource
    private Car someCar;
    
    public someMethod(Car someCar) {
        // sout
    }
}
</code></pre>
<ul>
<li>如何实现一个 LRU 算法</li>
<li>写下递归 n 的阶层</li>
<li>java 中 juc 包下哪些锁是 cas 操作？</li>
<li>synchronized 和可重入锁，JMM、volatile</li>
<li>mysql 根据性别查询不同的用户怎么加索引</li>
<li>mysql 索引</li>
<li>浏览器地址栏输入网址后的过程</li>
<li>聊了下设计模式</li>
<li>聊了下分布式事务</li>
<li>产品经理比较烂怎么办</li>
</ul>
<p>面试官 2：</p>
<ul>
<li>react 的生命周期</li>
<li>webpack 用过没</li>
<li>zookeeper 一致性原理了，zookeeper 核心原理是啥</li>
<li>有没有高并发经验</li>
<li>实现以下代码，模仿ConcurrentHashMap 的computeIfAbsent，但是要求同样的 key 和 mappingFunction同时请求的时候只计算一次，阻塞其他线程</li>
</ul>
<pre><code>public class ConcurrentHashMap {
    public V computeIfAbsent(K key,
            Function&lt;? super K, ? extends V&gt; mappingFunction) {
        /**
        /* 要求 mappingFunction 只计算一次，即同样 key、mappingFunction 
        /* 调用的时候只计算一次,mappingFunction,阻塞另一个线程的调用
        */
    }
}
</code></pre>
<h2 id="yz-公司">yz 公司：</h2>
<p>电话面（约 30 分钟）<br>
2. 为什么要使用分库分表<br>
3. 解释下一条 sql 在分库分表下是怎么查询的<br>
4. 项目中 mq 用来干嘛的<br>
5. mq 消息发送失败怎么处理<br>
6. inodb 索引<br>
7. 隔离级别<br>
8. mvcc，隔离级别怎么实现的<br>
9. 讲下一致性视图<br>
10. 行锁</p>
<h2 id="dd-公司">dd 公司</h2>
<p>电话面（约 1 小时 10 分）</p>
<ol>
<li>用户打分算法 bm5（听不清叫啥了）了解否</li>
<li>并发量有多少，请求量多少</li>
<li>微服务用的什么框架</li>
<li>简历上的校验框架干嘛的，有什么难点</li>
<li>介绍下 dubbo
<ol>
<li>dubbo 主要分层</li>
<li>注册中心挂了还能调用吗</li>
<li>讲述下服务端发起一次请求的过程</li>
<li>序列化机制有哪些</li>
<li>实现 dubbo 扩展机制 spi 要添加哪些类</li>
<li>序列化实现了解吗，为什么选用 hessian</li>
<li>负载均衡机制有哪些</li>
<li>让你来设计一个 rpc 框架，如何设计</li>
</ol>
</li>
<li>mysql 索引、mvcc</li>
<li>并发相关</li>
<li>
<ol>
<li>volatile 语义，使用场景、JMM
<ol>
<li>sychronized 原理、讲述下锁优化、锁膨胀</li>
<li>可重入锁和读写锁</li>
<li>线程池包下主要有哪些类，主要是怎么设计的</li>
<li>线程池中的阻塞队列有哪些</li>
<li>ConcurrentHashMap</li>
</ol>
</li>
</ol>
</li>
<li>有没有碰到过 oom、sql 优化经验</li>
<li>redis
<ol>
<li>事务了解吗</li>
<li>管道操作了解吗</li>
<li>有哪些数据结构</li>
<li>集群</li>
</ol>
</li>
<li>Spring Boot</li>
<li>
<ol>
<li>讲述下你的理解，和 Spring 有哪些区别
<ol>
<li>条件装配怎么实现的</li>
<li>如何实现一个 SpringBoot Starter</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mk-公司">mk 公司</h2>
<p>现场面（合计hr 面约 2 小时 30 分）</p>
<p>面试官 1：</p>
<ul>
<li>Hashmap、ConcurrentHashMap
<ul>
<li>HashMap 并发环境下有什么问题</li>
<li>为什么使用红黑树</li>
<li>红黑树 crud 哪个操作最快</li>
</ul>
</li>
<li>JVM 内存区
<ul>
<li>介绍下常量池</li>
<li>堆中哪些对象可以作为 gc-roots</li>
<li>讲述下类加载过程</li>
</ul>
</li>
<li>Sychronized
<ul>
<li>讲一下锁膨胀如何实现</li>
<li>JMM 内存模型</li>
</ul>
</li>
<li>线程池参数
<ul>
<li>核心线程数与最大线程数的区别</li>
<li>工作队列有哪几种</li>
<li>核心线程数满了以后添加新任务如何处理的</li>
<li>任务拒绝策略有哪些</li>
</ul>
</li>
<li>BeanFactory 与 FactoryBean 的区别</li>
<li>讲一下 mysql 索引
<ul>
<li>联合索引（A,B,C) 查询（B,C) 能否使用索引，为什么？</li>
<li>讲一下mysql 索引使用需要注意的地方</li>
<li>索引底层数据结构</li>
<li>为什么使用 b+树</li>
</ul>
</li>
<li>Dubbo 了解吗
<ul>
<li>负载均衡有哪些策略</li>
<li>一致性 hash 原理</li>
</ul>
</li>
<li>ThreadLocal 使用过吗
<ul>
<li>ThreadLocal 有什么问题？</li>
<li>怎么实现的</li>
</ul>
</li>
<li>Redis
<ul>
<li>String 数据结构是如何实现的</li>
<li>讲下跳表</li>
<li>备份策略</li>
<li>主从同步</li>
</ul>
</li>
</ul>
<p>面试官 2：</p>
<ul>
<li>设计模式
<ul>
<li>设计模式有哪些原则</li>
<li>策略模式</li>
<li>模板方法</li>
</ul>
</li>
<li>数据结构
<ul>
<li>遍历图有几种方式</li>
</ul>
</li>
<li>有没有 oom 过</li>
<li>老年代的对象的年龄都不大是什么原因？如何调优？</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nacos 服务删除失败的问题]]></title>
        <id>https://jiangjinxinn.github.io/post/nacos-fu-wu-shan-chu-shi-bai-de-wen-ti/</id>
        <link href="https://jiangjinxinn.github.io/post/nacos-fu-wu-shan-chu-shi-bai-de-wen-ti/">
        </link>
        <updated>2019-10-14T06:12:22.000Z</updated>
        <content type="html"><![CDATA[<p>在使用 Nacos 作为服务监控的功能的时候出现了一个问题：<br>
删除服务提示失败：<br>
<img src="https://jiangjinxinn.github.io//post-images/1571033820491.png" alt="" loading="lazy"></p>
<p>提示是对应的服务不存在<br>
但是实际上 nacos 的后台管理页面上是存在的，并且我的后台页面上还出现了两个同名的服务，其中一个可以删除成功，另一个会报服务不存在</p>
<p>回忆了下我之前的操作，其中一次在注册服务实例的时候，在服务名后面带上了 <code>@@</code>，加这个原先是为了做服务区分用的，用<code>@@</code> 字符是因为我在 nacos 的源码中看到他们是用 group + <code>@@</code> + serviceName 作为 service 的标识的，想模仿一波，贴近风格。。。</p>
<p>直接到代码中找原因，先找到抛出异常的地方<br>
<code>com.alibaba.nacos.naming.core.ServiceManager#easyRemoveService</code></p>
<pre><code>    public void easyRemoveService(String namespaceId, String serviceName) throws Exception {

        Service service = getService(namespaceId, serviceName);
        if (service == null) {
            // 这里抛出了异常，那么就是，service 为没有查询到
            throw new IllegalArgumentException(&quot;specified service not exist, serviceName : &quot; + serviceName);
        }

        if (!service.allIPs().isEmpty()) {
            throw new IllegalArgumentException(&quot;specified service has instances, serviceName : &quot; + serviceName);
        }

        consistencyService.remove(KeyBuilder.buildServiceMetaKey(namespaceId, serviceName));
    }
</code></pre>
<p>获取 service 的方法在这个接口中<br>
<code>com.alibaba.nacos.naming.core.ServiceManager#getService</code></p>
<pre><code>    public Service getService(String namespaceId, String serviceName) {
        if (serviceMap.get(namespaceId) == null) {
            return null;
        }
        // 这里直接从 map 中查询 key 为serviceName 的 Service
        return chooseServiceMap(namespaceId).get(serviceName);
    }
</code></pre>
<p>可以看到就是到存储了 service 的 concurrentHashMap 中查询 service</p>
<pre><code>    /**
     * Map&lt;namespace, Map&lt;group::serviceName, Service&gt;&gt;
     */
    private Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<p>这里没有查询到，说明 serviceMap 没有存储了相应的键值对数据</p>
<p>serviceMap 中没有存取数据，那控制后台上显示的服务实例数据是哪里来的呢？从 controller 的接口上查看下<br>
<code>com.alibaba.nacos.naming.controllers.CatalogController#listDetail</code></p>
<pre><code>  @RequestMapping(value = &quot;/services&quot;, method = RequestMethod.GET)
    public Object listDetail(HttpServletRequest request) {

        boolean withInstances = Boolean.parseBoolean(WebUtils.optional(request, &quot;withInstances&quot;, &quot;true&quot;));

        if (withInstances) {
            String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID,
                Constants.DEFAULT_NAMESPACE_ID);
            List&lt;ServiceDetailInfo&gt; serviceDetailInfoList = new ArrayList&lt;&gt;();
            int pageNo = Integer.parseInt(WebUtils.required(request, &quot;pageNo&quot;));
            int pageSize = Integer.parseInt(WebUtils.required(request, &quot;pageSize&quot;));
            String keyword = WebUtils.optional(request, &quot;keyword&quot;, StringUtils.EMPTY);

            List&lt;Service&gt; serviceList = new ArrayList&lt;&gt;(8);
            // 控制台上返回带数据来自这里，serviceList 传入serviceManager.getPagedService 方法中被填充了数据
            // 后台界面上有数据，说明这里返回了数据，继续往下看下
            serviceManager.getPagedService(namespaceId, pageNo, pageSize, keyword, StringUtils.EMPTY, serviceList, false);

            for (Service service : serviceList) {
                ServiceDetailInfo serviceDetailInfo = new ServiceDetailInfo();
                // 这里将 Service 的名字进行了转化，就是之前说的，serviceName 是 group + serviceName，这里要把 group 去掉
                serviceDetailInfo.setServiceName(NamingUtils.getServiceName(service.getName()));
                serviceDetailInfo.setGroupName(NamingUtils.getGroupName(service.getName()));
                serviceDetailInfo.setMetadata(service.getMetadata());

                Map&lt;String, ClusterInfo&gt; clusterInfoMap = getStringClusterInfoMap(service);
                serviceDetailInfo.setClusterMap(clusterInfoMap);

                serviceDetailInfoList.add(serviceDetailInfo);
            }

            return serviceDetailInfoList;
        } else {
            return serviceList(request);
        }
    }
</code></pre>
<p>进入到 <code>NamingUtils</code> 中看下具体是如何把 group 去掉，进行 name 转化的。</p>
<pre><code>public class NamingUtils {

    public static String getGroupedName(String serviceName, String groupName) {
        return groupName + Constants.SERVICE_INFO_SPLITER + serviceName;
    }

    public static String getServiceName(String serviceNameWithGroup) {
        if (!serviceNameWithGroup.contains(Constants.SERVICE_INFO_SPLITER)) {
            return serviceNameWithGroup;
        }
        // public static final String SERVICE_INFO_SPLITER = &quot;@@&quot;;
        // 这里是通过直接将字符串按 &quot;@@&quot; 分割，返回数据，所以如果服务的名字带有`@@`，`@@` 会被去掉
        return serviceNameWithGroup.split(Constants.SERVICE_INFO_SPLITER)[1];
    }

    public static String getGroupName(String serviceNameWithGroup) {
        if (!serviceNameWithGroup.contains(Constants.SERVICE_INFO_SPLITER)) {
            return Constants.DEFAULT_GROUP;
        }
        return serviceNameWithGroup.split(Constants.SERVICE_INFO_SPLITER)[0];
    }
}
</code></pre>
<p>从 <code>NamingUtils</code> 可以看出，返回前台界面的时候要将合并的数据，按<code>@@</code> 分割了，获取到服务对应的 group。</p>
<p>最后看下存入 service 信息的时候，是否如所预想的那样，service 的 name 和 group 合并后没有做处理的。<br>
<code>com.alibaba.nacos.naming.core.ServiceManager</code></p>
<pre><code>    public void putService(Service service) {
        if (!serviceMap.containsKey(service.getNamespaceId())) {
            synchronized (putServiceLock) {
                if (!serviceMap.containsKey(service.getNamespaceId())) {
                    serviceMap.put(service.getNamespaceId(), new ConcurrentHashMap&lt;&gt;(16));
                }
            }
        }
        // 可以看到存入 service 的时候，名字没有做处理
        serviceMap.get(service.getNamespaceId()).put(service.getName(), service);
    }
</code></pre>
<h3 id="总结">总结</h3>
<p>nacos 的服务可以分组，如文档所说，模型是 service --&gt; cluster --&gt; insttance，cluster 就是代码中的 group。在实际的代码层面上处理的时候，是将 service 和 cluster 合并成一个属性，用 <code>@@</code> 做分割。</p>
<pre><code class="language-java">/**
 * Service of Nacos server side
 * &lt;p&gt;
 * We introduce a 'service --&gt; cluster --&gt; instance' model, in which service stores a list of clusters,
 * which contain a list of instances.
 * &lt;p&gt;
 * This class inherits from Service in API module and stores some fields that do not have to expose to client.
 *
 * @author nkorange
 */
</code></pre>
<p>这里找到服务删除不掉，原因就是前面所说的，我之前测试的时候，出于一些原因（憨），在注册服务的时候<br>
<code>com.alibaba.nacos.api.naming.NamingService#registerInstance(java.lang.String, com.alibaba.nacos.api.naming.pojo.Instance)</code><br>
注册的服务的名字后面带上了<code>@@</code>，前台展示的时候，<code>@@</code> 由于字符串被去掉了，但是 nacos 上存取服务实例的 map 中的名称中实际上带有我添加的 <code>@@</code>，删除的时候就失败了，因为根据服务 name 查找不到（实际的 name 多了 <code>@@</code> 后缀）。</p>
<p>后台界面上出现两个同名的服务的原因也是因为这个，只是显示的服务名称相同，实际上是两个不同的服务。</p>
<p>为什么 nacos 在返回 service 的时候要将<code>@@</code> 去掉，由前所述因为 group 和 serviceName，返回的时候要把合并的字符，还原回去。</p>
<p>随后查看了下 nacos 中是有做字符检测的，但是正则写的有问题。。<br>
<code>com.alibaba.nacos.naming.core.Service#validate</code>，<br>
<code>com.alibaba.nacos.naming.core.Service#SERVICE_NAME_SYNTAX</code></p>
<pre><code class="language-java">    private static final String SERVICE_NAME_SYNTAX = &quot;[0-9a-zA-Z@\\.:_-]+&quot;;
</code></pre>
]]></content>
    </entry>
</feed>